<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="分布式系统（仅用于个人学习，笔记）1.1 认识分布式系统分布式系统有以下特点： （1）多进程。分布式系统中有多个进程并发运行 （2）不共享操作系统。通过网络通信传递消息来协作 （3）不共享时钟。所以很难只通过时间来定义两个事件的顺序 1.2 分布式系统的挑战1.2.1网络延迟问题分布式系统中的多个节点通过网络进行通信，但网络并不能保证数据什么时候到达，以及是否一定到达，有时网络甚至是不安全的。 例">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://nannaer.github.io/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="分布式系统（仅用于个人学习，笔记）1.1 认识分布式系统分布式系统有以下特点： （1）多进程。分布式系统中有多个进程并发运行 （2）不共享操作系统。通过网络通信传递消息来协作 （3）不共享时钟。所以很难只通过时间来定义两个事件的顺序 1.2 分布式系统的挑战1.2.1网络延迟问题分布式系统中的多个节点通过网络进行通信，但网络并不能保证数据什么时候到达，以及是否一定到达，有时网络甚至是不安全的。 例">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230417_150820_edit_5094932810995.jpg">
<meta property="og:image" content="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230417_150835.jpg">
<meta property="og:image" content="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230419_102112_edit_7687167362688.jpg">
<meta property="og:image" content="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230420_091731_edit_4384870563414.jpg">
<meta property="og:image" content="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230420_115317_edit_12556586318132.jpg">
<meta property="og:image" content="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230420_135954.jpg">
<meta property="article:published_time" content="2023-04-17T07:15:14.306Z">
<meta property="article:modified_time" content="2023-04-20T06:14:57.181Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230417_150820_edit_5094932810995.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://nannaer.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-分布式系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2023-04-17T07:15:14.306Z" itemprop="datePublished">2023-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分布式系统（仅用于个人学习，笔记）"><a href="#分布式系统（仅用于个人学习，笔记）" class="headerlink" title="分布式系统（仅用于个人学习，笔记）"></a>分布式系统（仅用于个人学习，笔记）</h1><h2 id="1-1-认识分布式系统"><a href="#1-1-认识分布式系统" class="headerlink" title="1.1 认识分布式系统"></a>1.1 认识分布式系统</h2><p>分布式系统有以下特点：</p>
<p>（1）多进程。分布式系统中有多个进程并发运行</p>
<p>（2）不共享操作系统。通过网络通信传递消息来协作</p>
<p>（3）不共享时钟。所以很难只通过时间来定义两个事件的顺序</p>
<h2 id="1-2-分布式系统的挑战"><a href="#1-2-分布式系统的挑战" class="headerlink" title="1.2 分布式系统的挑战"></a>1.2 分布式系统的挑战</h2><h3 id="1-2-1网络延迟问题"><a href="#1-2-1网络延迟问题" class="headerlink" title="1.2.1网络延迟问题"></a>1.2.1网络延迟问题</h3><p>分布式系统中的多个节点通过网络进行通信，但网络并不能保证数据什么时候到达，以及是否一定到达，有时网络甚至是不安全的。</p>
<p>例如，分布式系统中的消息传递可能会出现以下问题：</p>
<p>（1）消息丢失了</p>
<p>（2）我们可能认为消息丢失了，但实际上消息只是延迟到达</p>
<p>（3）网络可能会重传消息，导致收到重复的消息</p>
<p>（4）消息延迟可能会让我们认为某个服务已经因故障下线，但实际上没有</p>
<p>（5）消息可能以不同的顺序到达，或者不同的节点上消息到达的顺序不同</p>
<h3 id="1-2-2部分失效问题"><a href="#1-2-2部分失效问题" class="headerlink" title="1.2.2部分失效问题"></a>1.2.2部分失效问题</h3><p>在分布式系统中，系统可能一部分节点正常工作，而另一部分节点停止运行，或另一部分其实正常运行，但由于网络中断导致无法协同工作。系统的某些部分可能会以不可预知的方式宕机，这被称为“<em><strong>部分失效</strong></em>”。</p>
<p>难点在于部分失效是<em><strong>不确定的</strong></em>：如果你视图做任何涉及多个节点和网络的事情，那么它有时可能会工作，有时可能会出现不可预知的失败。</p>
<p>这种不确定性和部分失效的可能性，使得分布式系统难以捉摸和调试。尤其是当你的操作需要原子性时——要么在所有节点都成功，要么在所有节点都失败。在这种情况下，部分失效就会带来很大的复杂性和挑战，甚至严重影响系统的性能。</p>
<h3 id="1-2-3时钟问题"><a href="#1-2-3时钟问题" class="headerlink" title="1.2.3时钟问题"></a>1.2.3时钟问题</h3><p>分布式系统中，每台机器有自己的时钟，各个物理设备的本地时钟走时并不准确，可能比其他机器稍快或更慢。</p>
<p>另外，消息通过网络从一台机器传送到另一台机器也需要时间，但由于网络中的可变延迟，我们不知道消息传递到底花了多少时间。</p>
<h3 id="1-3-每个程序员都应该知道的数字"><a href="#1-3-每个程序员都应该知道的数字" class="headerlink" title="1.3 每个程序员都应该知道的数字"></a>1.3 每个程序员都应该知道的数字</h3><p><img src="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230417_150820_edit_5094932810995.jpg" alt="IMG_20230417_150820_edit_5094932810995"></p>
<p><img src="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230417_150835.jpg" alt="IMG_20230417_150835"></p>
<p>延迟（<code>Latency</code>），带宽（<code>BandWidth</code>）和吞吐量（<code>Throughput</code>）之间有什么区别？</p>
<p>用水管来举例，延迟表示通过管道需要花费的时间，带宽表示水管管道的宽度，每秒流过的水的数量就是吞吐量。</p>
<h2 id="2-分布式系统模型"><a href="#2-分布式系统模型" class="headerlink" title="2 分布式系统模型"></a>2 分布式系统模型</h2><h3 id="2-1-两将军问题"><a href="#2-1-两将军问题" class="headerlink" title="2.1 两将军问题"></a>2.1 两将军问题</h3><p>这座城市防守坚固，要想顺利占领它，两支军队必须同时进攻。如果同一时间仅一支军队进攻，将会战败。</p>
<p>同时，两位将军必须通过信使沟通并约定攻击时间，并且他们都必须确保另一位将军知道自己已同意了进攻计划，但由于传递确认消息的信使可能被俘虏造成消息丢失，即使双方不断确认已收到对方的上一条消息，也无法确保对方已与自己达成共识。</p>
<p>TCP的<em><strong>“三次握手”</strong></em>就是两将军问题的一个工程解。</p>
<h3 id="2-2-拜占庭将军问题"><a href="#2-2-拜占庭将军问题" class="headerlink" title="2.2 拜占庭将军问题"></a>2.2 拜占庭将军问题</h3><p>拜占庭故障模型描述的是系统中某些成员计算机不仅会发生故障和出现错误，甚至会故意篡改，<em><strong>破坏和控制系统的系统模型</strong></em>。</p>
<h3 id="2-3-系统模型"><a href="#2-3-系统模型" class="headerlink" title="2.3 系统模型"></a>2.3 系统模型</h3><p><strong>2.3.1 网络链路模型</strong></p>
<p><em><strong>网络分区</strong></em>指节点仍然正常工作，但它们之间的通信连接已经中断。</p>
<p>假设我们有一个发送者和接收者，它们通过一个双向的链路通信。一个链路有两个最基本的事件：<strong>发送事件</strong>，即将一条消息发送到链路上；<strong>接收事件</strong>，链路返回一条消息。</p>
<p>1.<em><strong>可靠链路</strong></em></p>
<p>可靠链路也称为完美链路。完美链路既不会丢失消息，也不会凭空捏造消息，但它<em><strong>可能会对消息重新排序</strong></em>。它有如下特点：</p>
<p>（1）可靠链路：如果进程p和q都正常工作，则进程p发送到q的每个消息都会被链路传递。</p>
<p>（2）没有重复：每条消息最多传递一次。</p>
<p>（3）不会无中生有：链路不会自己生成消息。换句话说，它不会传递一个从未发送过的消息。</p>
<p>2.<em><strong>公平损失链路</strong></em></p>
<p>公平损失链路消息可能会丢失，重复或重新排序，但消息最终会到达。公平损失链路有如下特点：</p>
<p>（1）公平损失：如果发送方和接收方都是正常运行的，且发送方不断重复发送消息，则消息最终会被送达。</p>
<p>（2）有限重复：消息只会重复发送有限的次数。</p>
<p>（3）不会无中生有：链路不会自己生成消息。这个特点和可靠链路一样。</p>
<p>3.<em><strong>任意链路</strong></em></p>
<p>任意链路是最弱的一种网络链路模型。这种网络链路允许任意的网络链路执行任意操作。</p>
<p><em><strong>这三种网络模型是可以相互转换的</strong></em>。例如，对于公平损失链路，可以通过不断重传丢失的消息，直到接收者接收到它们，并让接收者过滤重复的消息，把一条公平损失链路变成一条可靠链路。公正损失假设意味着任何网络分区（网络中断）只会持续有限的时间，不会永远持续下去，所以我们可以保证每条消息最终都会被接收。</p>
<p>使用加密技术可以将任意链路变成公平损失链路，例如<code>HTTPS</code>中使用<code>TLS</code>加密</p>
<p><strong>2.3.2 节点故障类型</strong></p>
<p>节点在回复消息时可能出现故障，从而导致该消息永久丢失，这就是节点故障问题。</p>
<p>故障类型主要分为以下三种类型：<strong>崩溃——停止（fail-stop），崩溃——恢复（fail-recover），拜占庭故障</strong>。</p>
<p>（1）崩溃——停止指一个节点停止工作后永远不会恢复。这可能是不可恢复的硬件故障，例如手机掉进马桶，意味着手机永久失灵。</p>
<p>（2）崩溃——恢复允许节点重新启动并继续执行剩余的步骤，一般通过持久化存储必要的信息来容忍这种故障类型。</p>
<p>（3）拜占庭故障如拜占庭将军问题一样，故障的节点可能不只会宕机，还可能以任意方式偏离算法，甚至恶意破坏系统。</p>
<p><strong>2.3.3 按时间划分系统模型</strong></p>
<p><strong>同步</strong>（Synchronous）系统模型是指，一个消息的响应时间在一个有限且已知的时间范围内。<strong>异步</strong>（Asynchronous）系统模型是指，一个消息的响应时间是无限的，无法知道一条消息什么时候会到达。</p>
<p><em><strong>异步系统才是更接近现实的系统</strong></em>。我们无法确保整个系统的所有组件都正常运行，因此在两地之间发送的消息得不到在有限时间内响应的保证。操作系统因内存不足挂起一个线程；Stop the World（垃圾回收也会暂停正在运行的线程）。即使这些情况很少发生，但只是短时间内的失效，就会使基于同步系统的假设失效，为同步系统设计的应用也随之出错。</p>
<p>为异步系统设计的算法是非常健壮的，因为它们不受任何临时网络中断或延迟的影响。不幸的是，分布式系统中的一些问题在异步系统中无法解决，比如<code>FLP</code>不可能定理，因此引出了第三种模型——部分同步（Partially Synchronous）系统。</p>
<p>在部分同步系统模型中，我们假设系统在大部分时间是同步的，但偶尔会因为故障转变为异步系统。</p>
<h3 id="2-4-消息传递语义"><a href="#2-4-消息传递语义" class="headerlink" title="2.4 消息传递语义"></a>2.4 消息传递语义</h3><p>由于网络和节点不可靠，这些消息可能会丢失，为了解决消息丢失问题，会让节点重复发送信息，这意味着消息可能会发送多次。例如重传消息正好是用户银行扣款信息。</p>
<p>上述问题最常见的解决方法是幂等操作。<em><strong>幂等操作</strong></em>是指多次操作产生相同的结果，且不会有任何其他影响。</p>
<p>幂等操作会对系统进行严格的约束，我们总是无法准确知道另一端操作结果是成功还是失败，我们只能一直等待确认请求，保证每个操作都是幂等的代价是昂贵的。在大多数情况下，我们可以给每条消息一个唯一的表示符，接收者可以避免执行执行过的操作。</p>
<p>按照消息传递和处理次数，有如下几种可能的消息传递语义：</p>
<p>（1）<strong>最多一次</strong>（At Most Once）：消息最多传递一次，消息可能丢失，但不会重复。</p>
<p>（2）<strong>至少一次</strong>（At Least Once）：系统保证每条消息至少会发送一次，消息不会丢失，但在有故障的情况下可能导致消息重复发送。</p>
<p>（3）<strong>精准一次</strong>（Exactly Once）：消息只会被精确传递一次。消息不丢失不重复。</p>
<p>我们关心的是消息被处理的次数，而不是消息被送达的次数。精确传递一次难以实现，因为想要建立可靠的链路，就必须重复传递某些信息。于是我们尽可能做到精确处理一次消息，然后通过忽略后续重复的消息来达到看起来是精准一次的效果。</p>
<p><strong>对于一些流式处理框架或消息队列来说，实现精准一次语义是非常重要的，尤其是输出端实现“精准一次”输出数据。</strong></p>
<h2 id="3-分布式数据基础"><a href="#3-分布式数据基础" class="headerlink" title="3 分布式数据基础"></a>3 分布式数据基础</h2><p>本章我们重点讨论分布式数据基础，涉及从单台机器转到分布式系统后，我们该如何分散存储数据集，该如何进行数据同步。软件工程没有银弹，引入分布式系统是万能解药吗？什么是数据一致性？什么是强一致性，弱一致性和最终一致性？</p>
<h3 id="3-1-分区"><a href="#3-1-分区" class="headerlink" title="3.1 分区"></a>3.1 分区</h3><p><strong>垂直分区和水平分区</strong></p>
<p>垂直分区是对表的列进行拆分，每个分区都包含了其中列对应的所有行。例如，可以将不经常使用的列或者一个包含了大text类型或BLOB类型的列垂直分区。</p>
<p>水平分区是对表的行进行拆分。例如将一个包含十年订单记录的表水平拆分为十个不同的分区。</p>
<h4 id="3-1-1-水平分区算法"><a href="#3-1-1-水平分区算法" class="headerlink" title="3.1.1 水平分区算法"></a>3.1.1 水平分区算法</h4><p>（1）<em>范围分区</em></p>
<p>根据指定的关键字将数据集拆分为若干连续的范围，每个范围存储到一个单独的节点上。</p>
<p><em><strong>缺点</strong></em>：</p>
<ol>
<li>无法使用分区键之外的其他关键字进行范围查询</li>
<li>当查询的范围比较大且位于多个节点时，性能较差</li>
<li>某些数据热点现象，从而造成某些节点负载很高</li>
</ol>
<p>（2）<em>哈希分区</em></p>
<p>将指定的关键字经过一个哈希函数的计算，根据计算得到的值决定该数据集的分区。</p>
<p>哈希分区的<em><strong>优点</strong></em>是数据分布几乎随机，相对均匀，能够在一定程度避免热点问题。</p>
<p>哈希分区的<em><strong>缺点</strong></em>是：</p>
<ol>
<li>在不额外存储数据的情况下，无法执行范围查询</li>
<li>在添加或删除节点时，由于每个节点都需要一个相应的哈希值，所以增加节点需要修改哈希函数，这会导致许多现有的数据都要重新映射，引起数据大规模移动，并且在此期间，系统可能无法继续工作</li>
</ol>
<p>（3）一致性哈希</p>
<p>在分布式系统中用来缓解哈希分区增加或删除节点时引起的大规模数据移动问题。</p>
<p>一致性哈希算法将整个哈希值组织成一个抽象的圆环，称为哈希环。</p>
<ol>
<li>将分布式系统节点映射到圆环上</li>
<li>将需要存储的数据的关键字输入哈希函数，计算出哈希值，根据哈希值将数据映射到哈希环上</li>
<li>向集群中新添加一个节点，按照顺时针计算的方法，原本存储到节点<code>N2</code>上的关键字a将转移到<code>N4</code>上，其他数据保持不动</li>
</ol>
<p><strong>一致性哈希对于节点的增减只需要重新分配哈希环上的一部分数据，改善了哈希分区大规模迁移的缺点。此外，一致性哈希也不需要修改哈希函数，直接将新节点指定到哈希环上的某个位置即可。</strong></p>
<p><strong>但是，一致性哈希仍然有明显的缺点，当系统节点太少时，还是容易产生数据分布不均的问题。另外，一个较为严重的缺点是，当一个节点发生异常需要下线时，该节点的数据全部转移到顺时针方向的节点上，从而导致顺时针方向节点存储大量数据，大量负载会倾斜到该节点。</strong></p>
<p>解决方案：<strong>引入虚拟节点</strong>，一个物理节点不再只对应哈希环上一个点，而是对应多个节点。虚拟节点越多，数据分布越均匀。</p>
<p>如果系统中有不同性能的机器，虚拟节点也很有用。<strong>例如，系统中有一台机器的性能是其他机器的两倍，那么我们可以让这台机器映射出两倍于其他机器的节点数，让它来承担更多的负担。</strong></p>
<p>不过，在不额外存储数据的情况下，一致性哈希仍然无法高效地进行范围查询，任何范围查询都会发送到多个节点上。</p>
<h4 id="3-1-2-分区的挑战"><a href="#3-1-2-分区的挑战" class="headerlink" title="3.1.2 分区的挑战"></a>3.1.2 分区的挑战</h4><p>在一个<strong>垂直分区</strong>的数据集中，<strong>将不同表的数据组合起来的查询（join）会非常低效</strong>，因为这些请求可能需要访问多个节点的数据。这种情况在水平分区的系统中可以避免，因为每一行的所有数据都位于同一个节点中，但是，<strong>对于需要查询许多行的范围查询</strong>来说，可能这些行位于不同的节点，<strong>请求也会访问多个节点</strong>。</p>
<h3 id="3-2-复制"><a href="#3-2-复制" class="headerlink" title="3.2 复制"></a>3.2 复制</h3><p>为了提高可用性，除了分区还需要复制。复制是将同一份数据冗余存储在多个节点上，节点间通过网络来同步数据，使之保持一致。一个存储了复制数据的节点称为副本。复制可以和分区一起使用。</p>
<p><strong>复制的主要好处有：</strong></p>
<p>（1）<strong>增强数据的可用性和安全性</strong>。</p>
<p>（2）<strong>减少往返时间</strong>。例如通过复制技术把数据存储到各个数据中心，可以将全国各地甚至全球不同用户的请求重定向到离用户为止更近的副本，减少往返时间，提升响应速度。</p>
<p>（3）<strong>增加吞吐量</strong>。一台服务器能够处理的请求数存在物理上限，这种情况下复制出同样的几台服务器，可以提供更多处理读写请求的机器，系统的处理性能能够成本增长。</p>
<p>理想情况下，<strong>复制应该对客户端来说无感知，即营造出一种每份数据只有一个副本的假象</strong>。要实现理想的情况总不太容易，网络延迟总会“捣鬼”。有时为了保障系统的性能，就需要放弃一些其他的属性，甚至允许在特定的条件下，返回一些过期的，反直觉的数据。</p>
<p>下面我们讨论三种常用复制类型：（1）<strong>单主复制</strong>（2）<strong>多主复制</strong>（3）<strong>无主复制</strong></p>
<h4 id="3-2-1-单主复制"><a href="#3-2-1-单主复制" class="headerlink" title="3.2.1 单主复制"></a><strong>3.2.1 单主复制</strong></h4><p>系统中一个副本为主节点，客户端的写请求必须发送到主节点；其余的副本称为从节点，从节点只能处理读请求，并从主节点同步最新的数据。</p>
<p>主节点收到写请求时，除了将数据写入本地存储，还要负责将这次数据变更同步给所有从节点，以确保所有的副本保持一致。数据变更同步具体是同步操作日志还是转发请求，不同系统有着不同的实现。</p>
<p>根据系统以何种方式同步复制，又可将单主复制分为三类：同步复制，异步复制和半同步复制。</p>
<p><strong>同步复制中的主节点执行完一个写请求后，必须等待所有从节点都执行完毕，并收到确认信息后，才可以回复客户端写入成功</strong>。</p>
<p><strong>异步复制中主节点执行完写请求后，会立即将结果返回给客户端，无需等待其他副本是否写入完成</strong>。</p>
<p><strong>半同步复制，主节点只需要等待至少一个从节点同步写操作并返回完成信息即可，不要等待所有的节点都完成。</strong></p>
<p>总的来说，<strong>单主复制的主要优点</strong>有：</p>
<ol>
<li>简单易懂，易于实现</li>
<li>仅在主节点执行并发写操作，能够保证操作的顺序，避免了还要考虑如何处理各个节点数据冲突这类复杂的情况，这个特性使得单主复制更容易支持事务类操作，分布式事务是非常消耗性能的</li>
<li>对于大量读请求工作负载的系统，单主复制是可扩展的，可以通过增加多个从节点来提升读的性能</li>
</ol>
<p><strong>单主复制的主要缺点</strong>有：</p>
<ol>
<li>面对大量写请求工作负载时系统很难进行扩展，因为系统只有一个主节点，写请求性能瓶颈由单个节点（主节点）决定</li>
<li>当主节点宕机时，从节点提升为主节点不是即时的，可能会造成一些停机时间，甚至产生错误</li>
</ol>
<p>对于第二个缺点需要展开分析。分布式系统执行故障切换有两种方法：<strong>手动切换</strong>和<strong>自动切换</strong>。</p>
<ol>
<li>手动切换可能导致较长的停机时间</li>
<li>自动切换，即从节点通过心跳超时检测到主节点已经宕机，然后尝试称为整个集群的主节点。这种方式快，不需要人工介入，能够自动容错，但也相对危险。<strong>倘若两个从节点同时检测到主节点失效，或者网络分区导致从节点认为主节点失效，但其实主节点仍然正常工作，这两种方式都会导致产生两个主节点。这种情况称为“脑裂”，两个主节点都在处理写请求。</strong></li>
</ol>
<p>自动切换最重要的问题是如何使系统中只有一个主节点，同时在主节点出现故障时自动，正确地选举出新主节点？该问题被称为<strong>领导者选举问题</strong>。</p>
<p><strong>处理从节点故障就简单许多</strong>，如果网络分区导致数据滞后，可以通过日志偏移量与主节点继续同步数据。如果从节点故障不可恢复，则可以换上新的从节点重新复制主节点的数据。</p>
<h4 id="3-2-2-多主复制"><a href="#3-2-2-多主复制" class="headerlink" title="3.2.2 多主复制"></a>3.2.2 多主复制</h4><p>单主复制适合大量读工作负载的系统，但<strong>单主复制在写性能，可扩展性方面有着一定的局限性</strong>。对于写请求负载要求严格的系统，一个自然的想法是增加多个主节点来分担写请求的负载，<strong>这种由多个节点充当主节点的数据复制方式称为多主复制</strong>。</p>
<p>多主复制和单主复制的显著区别是，由于多主复制不止一个节点处理写请求且网络存在延迟，这就意味着节点可能会对某些请求的正确顺序产生分歧，导致多个节点上的数据不一致，这种现象称为<strong>数据冲突</strong>。</p>
<p> <img src="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230419_102112_edit_7687167362688.jpg" alt="IMG_20230419_102112_edit_7687167362688"></p>
<p><strong>如果你的分布式系统没有清楚地处理数据冲突，那么任何正确的行为都是良好的运气，而不是良好的设计！</strong></p>
<p>为了使系统在这种情况下仍然能够正常运行，必须解决数据冲突，最好的解决方法是避免冲突产生。例如，<strong>特定账号总是交给特定的主节点来处理，可以通过一个哈希函数来讲特定账户的所有请求路由到相同的主节点上，这样可以避免同一份数据在多个节点上更新，在一定程度上避免冲突的产生</strong>。</p>
<p>有时冲突无法避免，根据系统特性，解决冲突的办法有多种，一些常见的冲突解决方法有：</p>
<p>（1）<strong>由客户端解决冲突</strong>。客户端下次读取系统中冲突数据的时候，将冲突数据全部返回给客户端，客户端选择合适的数据并返回给存储系统，存储系统以此数据作为最终确认的数据，覆盖所有冲突的数据。</p>
<p>（2）<strong>最后写入胜利</strong>（<code>LWW</code>）。让系统中每个节点为每个写入请求标记上唯一时间戳或唯一自增ID，当冲突发生时，<strong>系统选择具有最新时间戳或最新ID版本的数据，并丢弃其他写入的数据</strong>。但<em><strong>由于分布式系统很难有一个统一的全局事件的概念，可能造成数据损失</strong></em>。</p>
<p>（3）因果关系追踪。例如先有发帖操作才会有回帖操作。</p>
<p>（4）无冲突复制数据类型。</p>
<p>综上所述，多主复制的优点有：</p>
<ol>
<li>增加主节点容错性。</li>
<li>可以在多个节点执行写请求，分担写负载的压力。</li>
<li>应用程序可以将请求路由到不同的主节点，通常会路由到地理位置最近的节点，以减少往返时间，提升写请求的响应速度。</li>
</ol>
<p>多主复制的缺点是它的复杂性，由于可以多个节点上执行写操作，可能经常产生数据冲突，随着节点数量的增加，有时无法很好滴解决产生的数据冲突，需要人工干预。</p>
<p>由于多主复制带来的复杂性远超它的好处，因此很少会在单个数据中心使用多主复制来构建分布式系统。<strong>多主复制一般用于多个数据中心的存储系统，避免写请求跨越数据中心。例如一个全球服务，在全球各地有多个数据中心，此时可以将请求路由到地理位置更近的数据中心中的主节点，以加快访问速度。</strong></p>
<h4 id="3-2-3-无主复制"><a href="#3-2-3-无主复制" class="headerlink" title="3.2.3 无主复制"></a>3.2.3 无主复制</h4><p>客户端将写请求并发地发送给几个节点后，一旦得到其中一些节点的确认响应，就认为此次写成功了，然后继续发送下一个请求。</p>
<p>如果写请求在节点1和节点3上成功，但在节点2上失败了，那么此时分布式存储系统中有两个节点上存储了新的值，但有一个节点存储了旧的值。</p>
<p>如果此时读取数据，则客户端既可能读到旧的数据，也可能读到新的数据，系统肯定不能这样工作。</p>
<p><strong>为了解决这个问题，和写请求一样，客户端不止会从一个节点读取数据，读请求也会同时发送给多个节点，然后获取节点上的数据和数据的版本号，客户端可以根据所有响应中版本号决定应该使用哪个值，应该丢弃哪个值。</strong></p>
<p>虽然这种情况下客户端可以识别出旧的数据，但我们仍然需要修复旧的数据，不能访问旧的数据一直在那。因此需要以某账方式将其与其他节点的数据保持一致，毕竟复制技术的母的是让多个节点存储相同的数据。</p>
<p>Dynamo架构中同时使用了以下两种数据修复方式：</p>
<p>（1）读修复。读修复其实就是多主复制中剃刀的让客户端负责更新数据。</p>
<p>（2）反熵过程。新建一个后台进程来修复数据，该进程找出错误的数据，并从存储最新的数据的节点中奖数据复制到错误的节点。和基于领导者的复制不同，反熵过程不保证写操作的顺序，只保证最后结果一样。</p>
<p>进行反熵过程修复时，我们肯定不希望一个个比较数据是否一致，这需要传输很多数据进行对比。哈希树，把数据按关键字分为几个范围，每个范围计算出一个哈希值并作为树的子节点，然后一层层合并到根节点。哈希树的特点是，树的每个分支都可以独立进行对比，不要求完全传输整棵树；同时，如果两棵树的根节点相同，那么叶子节点的值也相同，不要求完全传输整棵树；同时，如果两棵树根节点相同，那么叶子结点的值也相同，就不需要再检查了。<strong>如果根节点不同，继续往子节点查找（只传输这部分子节点的数据），直到叶子结点找到不同的关键字所在的范围</strong>。</p>
<p><strong>通过哈希树的根节点开始比较哈希值，就能快速找到哪些范围的哈希值发生了变化，快速定位不一致的数据，并且只传输较少的数据进行比较</strong>。</p>
<p>并非所有无主复制系统都需要实现读修复和反熵过程。<strong>对于没有反熵过程的系统，如果一些数据很久没有被读到，就不会执行读修复过程，那么某些副本上可能会缺少这些数据</strong>。</p>
<p><em><strong><u>基于Quorum的数据冗余机制</u></strong></em></p>
<p><strong>在一个由N个节点组成的系统中，我们要求至少W个节点写入成功，并且需要同时从R个节点中读取数据，只要W+R&gt;N且W&gt;N/2，则读取的R个返回值中至少包含一个最新的值。</strong></p>
<p>W&gt;N/2这条规则主要用于保证数据的串行化修改，两个不同的写请求不能同时成功修改一份数据。</p>
<p>W值越大R值越小，系统的读操作性能就越好。反之写操作的性能越好。</p>
<p>例如，如果一个应用程序的写请求较少，但读请求非常频繁，那么可以设置W=N与R=1。当然这种参数配置会让应用程序的写入速度变慢，可用性降低，因为一个节点故障就会阻塞整个写操作的完成。</p>
<h3 id="3-3-CAP定理"><a href="#3-3-CAP定理" class="headerlink" title="3.3 CAP定理"></a>3.3 CAP定理</h3><p>CAP定理指在一个异步网络环境中，对于一个分布式读写存储系统来说，只能满足以下三项中的两项，而不能满足全部三项：</p>
<p><strong>一致性（Consistency）</strong></p>
<p><strong>可用性（Availability）</strong></p>
<p><strong>分区容错性（Partition Tolerance）</strong></p>
<p><strong>一致性</strong>可以这么理解，客户端访问所有节点，返回的都是同一份最新的数据。<strong>可用性</strong>是指，每次请求都能获取非错误的响应，但不保证获取的数据是最新数据。<strong>分区容错性</strong>是指，节点之间由于网络分区导致消息丢失的情况下，系统仍能继续正常运行。</p>
<p>CAP定理的重要意义在于，它帮助软件工程师在设计分布式系统时，施加基本的限制，不必浪费时间去构建一个完美的系统。</p>
<p>对于一个分布式系统来说，节点之间是通过网络通信的，只要有网络，必然出现消息延迟或丢失，网络分区故障是必然发生的，所以分区容忍性是一个基本的要求。CAP定义就是用来探讨在这种情况下，在系统设计上必须做出的取舍。因此<code>CP</code>还是<code>AP</code>这取决于在保证分区容错性（P）的情况下选择一致性（C）还是可用性（A）。</p>
<p>其次，系统在正常运行的过程中，虽然没有网络分区发生，但网络延迟还是会存在。而CAP定理的经典解释是忽略网络延迟的，但在实际中延迟和分区紧密相关。系统在出现网络延迟的时候，如果选择放弃处理请求，则相当于降低了可用性；如果选择继续处理请求，由于延迟存在，则会降低系统的一致性。系统需要在网络延迟时做出权衡。</p>
<h4 id="3-3-1-PACELC-定理"><a href="#3-3-1-PACELC-定理" class="headerlink" title="3.3.1 PACELC 定理"></a>3.3.1 <code>PACELC</code> 定理</h4><p><code>PACELC</code>定理指出，在分布式系统存在网络分区（P）的情况下，必须在可用性（A）和一致性（C）之间做出选择。</p>
<p>​                                            —（是）—分区—（否）—</p>
<p>​                                            |                                            |</p>
<p>​                                        ————                            ————</p>
<p>​                                    |                 |                        |                |</p>
<p>​                               可用性        一致性                延迟            一致性</p>
<h4 id="3-3-2-BASE定理"><a href="#3-3-2-BASE定理" class="headerlink" title="3.3.2 BASE定理"></a>3.3.2 <code>BASE</code>定理</h4><p>BASE即基本可用，软状态和最终一致性的首字母缩写。</p>
<p>所谓<strong>最终一致性</strong>是指，当客户端更新某个数据时，可能因为网络分区或延迟，导致数据没有即时同步到所有副本，系统中存在新旧数据。此时系统仍然允许继续读写数据，但在最终某个时刻，系统保证这个更新操作一定会同步到所有副本。</p>
<p><strong>最终一致性是一种能够接受的方案，适用于允许一些延迟的场景，例如帖子的点赞数等。</strong></p>
<h3 id="3-4-一致性模型"><a href="#3-4-一致性模型" class="headerlink" title="3.4 一致性模型"></a>3.4 一致性模型</h3><p>一致性模型是指，在并发编程中，系统和开发者之间的一种约定，如果开发者遵循某些规则，那么开发者执行读操作或写操作的结果是可预测的。</p>
<p>一致性模型本质上定义了写操作的顺序和可见性，即并发写操作执行的顺序是怎样的，写操作的结果何时能够被别的进程看见。</p>
<h4 id="3-4-1-线性一致性"><a href="#3-4-1-线性一致性" class="headerlink" title="3.4.1 线性一致性"></a>3.4.1 线性一致性</h4><p><strong>线性一致性</strong>的严格定义是，给定一个执行历史，执行历史根据并发操作可以扩展为多个顺序历史，只要从中找到一个合法的顺序历史，那么该执行历史就是线性一致的。</p>
<p><strong>线性一致的代价：分布式系统中的线性一致性最困难的是需要一个全局时钟</strong>，这样才能知道每个节点事件发生的时间和全局顺序，但分布式系统中准确的全局时钟是非常难以实现的。</p>
<h4 id="3-4-2-顺序一致性"><a href="#3-4-2-顺序一致性" class="headerlink" title="3.4.2 顺序一致性"></a>3.4.2 顺序一致性</h4><p>约束比线性一致性弱，只要求同一个客户端的操作在排序后保持先后顺序不变，但不同客户端之后的先后顺序是可以任意改变的。</p>
<p><strong>有时顺序一致性往往更实用。例如，在一个社交网络应用中，一个人通常不关心它看到的所有朋友的帖子的顺序，但对于具体的某个朋友，仍然以正确的顺序显示该朋友发的帖子会更符合逻辑。</strong></p>
<h4 id="3-4-3-因果一致性"><a href="#3-4-3-因果一致性" class="headerlink" title="3.4.3 因果一致性"></a>3.4.3 因果一致性</h4><p><strong>是一种比顺序一致性更弱一些的一致性模型，它与顺序一致性一样不依赖于全局操作的顺序。</strong></p>
<p>最典型的因果关系就是社交网络中的发帖和评论关系，根据因果关系，必须先有发帖才能有对于该帖子的评论，所以发帖操作必然在评论操作之前。</p>
<h4 id="3-4-4-最终一致性"><a href="#3-4-4-最终一致性" class="headerlink" title="3.4.4 最终一致性"></a>3.4.4 最终一致性</h4><h4 id="3-4-5-以客户端为中心的一致性模型"><a href="#3-4-5-以客户端为中心的一致性模型" class="headerlink" title="3.4.5 以客户端为中心的一致性模型"></a>3.4.5 以客户端为中心的一致性模型</h4><p>前面四种一致性模型归为一类，称为<strong>以数据为中心的一致性模型</strong>。以数据为中心的一致性模型旨在为数据存储系统提供一个系统级别的全局一致性视图，我们讨论这类一致性模型的角度都是当并发的客户端同时更新数据时，考虑每个系统每个副本数据是否一致，以及系统系统的一致性。</p>
<p>还有一类<strong>以客户端为中心的一致性模型</strong>，考虑客户端的读写请求的结果，从而推断出系统的一致性。</p>
<p><strong>单调读</strong></p>
<p><strong>单调写</strong></p>
<p><strong>读你所写</strong></p>
<p>PRAM一致性也称为<strong>FIFO一致性</strong>，由单调读，单调写和读你所写三个一致性模型组成。PRAM一致性要求：同一个客户的多个写操作，将被所有的副本按照同样的执行顺序观察到，但不同客户端发出的写操作可以以不同的执行顺序被观察到。</p>
<h3 id="3-5-隔离级别"><a href="#3-5-隔离级别" class="headerlink" title="3.5 隔离级别"></a>3.5 隔离级别</h3><p>隔离级别定义了并行系统中事务的结果何时，以何种方式对其他并发事务可见。隔离性属于事务ACID四个属性之一。</p>
<p>我们主要研究以下几种比较常见的隔离级别：</p>
<ol>
<li>串行化</li>
<li>可重复读</li>
<li>快照隔离</li>
<li>读已提交</li>
<li>读未提交</li>
</ol>
<p><strong>下图矩形的模型的可用性为不可用，椭圆中的模型可用性为高可用：</strong></p>
<p><img src="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230420_091731_edit_4384870563414.jpg" alt="IMG_20230420_091731_edit_4384870563414"></p>
<p>隔离级别定义了什么事不可行的，即在已知的异常中防止哪些异常情况发生。当然，越强的隔离级别能防止越多的异常，但性能往往越低。所以在研究各个隔离级别之前，我们先来看看<strong>并发事务可能发生的异常情况</strong>。</p>
<p><strong>脏写</strong>是指一个事务覆盖率另一个仍在运行中，尚未提交的事务写入的值。</p>
<p><strong>脏读</strong>是指一个事务读到了另一个尚未提交的事务写入的值。例如事务B读到事务A写入的x值为1，可是之后事务A却回滚了该操作。</p>
<p><strong>不可重复读</strong>指在一个事务中查询一个值两次，但两次查询返回的值不同，不可重复读也叫模糊读。不可重复读和脏读的区别是，脏读是由于事务回滚导致的，而<strong>不可重复读读到的是其他事物已经提交的数据</strong>。</p>
<p><strong>幻读</strong>是指当一个事务进行条件查询时，另一个事务在中间插入或删除匹配该条件的数据，这时事务再去读，就会发生幻读。简而言之，幻读就是读到的数据项变多或变少了。</p>
<p><strong>更新丢失</strong>是指当两个事务读取同一个值，然后都试图将其更新为新的不同的值时，就会发生更新丢失。</p>
<p><strong>读偏斜</strong>是指读到数据一致性约束被破坏的数据，这里的一致性约束是业务逻辑层面的。</p>
<p><strong>写偏斜</strong>是指两个并发事务都读到了相同的数据集，但随后各自修改了不相干的数据集，导致数据一致性约束被破坏。</p>
<p><img src="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230420_115317_edit_12556586318132.jpg" alt="IMG_20230420_115317_edit_12556586318132"></p>
<h3 id="3-6-一致性和隔离级别的对比"><a href="#3-6-一致性和隔离级别的对比" class="headerlink" title="3.6 一致性和隔离级别的对比"></a>3.6 一致性和隔离级别的对比</h3><h4 id="3-7-本章小结"><a href="#3-7-本章小结" class="headerlink" title="3.7 本章小结"></a>3.7 本章小结</h4><p>设计一个分布式存储系统是如此之难：</p>
<p>（1）出发点是提高性能，当单机数据量太大时，需要在多台服务器上对数据进行分区。</p>
<p>（2）由于有多台服务器，系统可能出现更多的故障。如果有数千台服务器，那么也许每天都有机器故障，所以我们需要系统能够自动容错。</p>
<p>（3）为了提高容错性，需要复制数据到多台服务器上，一般一个数据项在整个集群上会有2到3个数据副本。</p>
<p>（4）数据的复制会导致数据不一致。</p>
<p>（5）为了提高一致性往往会导致更低的性能，这与我们的初衷恰恰相反。</p>
<p>没有完美的系统，我们需要系统处理更好还是更快？正因为这种取舍的存在，才诞生了如此多的概念和模型。</p>
<h2 id="4-分布式共识"><a href="#4-分布式共识" class="headerlink" title="4 分布式共识"></a>4 分布式共识</h2><h3 id="4-1-分布式共识简介"><a href="#4-1-分布式共识简介" class="headerlink" title="4.1 分布式共识简介"></a>4.1 分布式共识简介</h3><p>共识就是在一个可能出现任意故障的分布式系统中的多个节点对某个值达成共识。</p>
<h4 id="4-1-2-为什么要达成共识"><a href="#4-1-2-为什么要达成共识" class="headerlink" title="4.1.2 为什么要达成共识"></a>4.1.2 为什么要达成共识</h4><p>我们已经了解了分布式系统的几个主要难题，包括网络不可靠问题，时钟不一致问题和节点故障问题。</p>
<p>在分布式系统领域，状态机复制（<code>SMR</code>）是解决上述难题的一种常规方法。状态机复制也叫做复制状态机或多副本状态机，所谓状态机，包括一组状态，一组输入，一组输出，一个转换函数，一个输出函数和一个独特的“初始”状态。<strong>一个状态机从“初始”状态开始，每个输入都被传入转换函数和输出函数，以生成一个新的状态和输出。</strong></p>
<p>状态机必须具备确定性：多个相同状态机的副本，从同样的“初始”状态开始，经历相同的输入序列后，会达到相同的状态，并输出相同的结果。</p>
<p><strong>实现状态机复制常常需要一个多副本日志（Replicated Log）系统</strong>，这个原理受到与日志相关的经验启发：如果日志的内容和顺序都相同，多个进程从同一状态开始，并且从相同的位置以相同的顺序读取日志内容，那这些进程将生成相同的输出，并且结束在相同的状态。</p>
<p><strong>共识算法常用来实现多副本日志，共识算法使得每个副本对日志的值和顺序达成共识，每个节点都存储相同的日志副本，这样整个系统中的每个节点都能有一致的状态和输出。最终，这些节点看起来就像一个单独的，高可用的状态机。</strong></p>
<p><strong>状态机复制可解决的分布式难题：</strong></p>
<p><img src="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/IMG_20230420_135954.jpg" alt="IMG_20230420_135954"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://nannaer.github.io/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" data-id="clgoqb13n0000yov7dnpv2gdl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/04/15/linuxPL/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/15/linuxPL/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>