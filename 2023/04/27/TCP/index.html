<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="TCP">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://nannaer.github.io/2023/04/27/TCP/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="TCP">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad5181cb911e12~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/11/16dbb2fbdaebd148~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad5181c634aed0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad5182f90d0bb5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/9/16dafd4097c7d058~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad518763d230b6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d658980af614477296e95ae5f3f658f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b57f577bc8b460fbf804c728538d230~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/649f7216e18147ee9411d1424fd71792~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d499ad8e97c4c48942e39a7bd195652~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59260fc36dfa468693085a6ac4600448~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16a4bb980c144a5ea9e2f6cf86360d92~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e260cd0cd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e147f6672~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e4ee94a57~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e4dcc0174~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e51db4162~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e54362613~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e84446756~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e81b1e6df~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e887eea11~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e8a06ec69~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134ba7385716~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134ba78527c6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134ba7638486~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/40.png">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134be85cf9f1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134c2146ce36~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518ccedac1b6e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518cceddbdcf6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518ccee187690~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518ccee4d8711~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518cd1664fa5d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c618264239~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c69b0f0f8e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c61961ba78~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/30/16e1a9da7d44c03d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c69a12791c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c6a3ca620d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c5c635f86~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4be8611658~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4be8843d80~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c5c7ae349~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/17102ef66f71cbd6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c6e0a8f69~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/22/16b7c9fb02bff057~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/28/16b9dae5efc47de8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/23/16918ddaf0b49c7e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/23/16918ddaf0d4afa5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba36e681b24ff3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba36e691c556be~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba36e68300ff13~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba36e691d04901~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/3/169e2dc0888e6b83~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/3/169e2dc0821ff4f9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/3/169e2dc0c15f46e5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/25/169230452f26de90~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/25/169230452a3ad54a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/25/169252c596fbaac0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53ee520a443~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53ee58979c9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53ee57fc0cb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53ee593eeca~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53f205214ae~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a02b90d9589384~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a02b90d978ff34~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a02b91ae14ef21~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4b9038f7aa~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4b904314f8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4b90306b56~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/15/16dce163cb0bd1d8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4bdb2a32f6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c6fa323bd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="og:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c703303df~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
<meta property="article:published_time" content="2023-04-27T06:19:57.731Z">
<meta property="article:modified_time" content="2023-05-01T05:12:28.851Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad5181cb911e12~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://nannaer.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-TCP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/27/TCP/" class="article-date">
  <time datetime="2023-04-27T06:19:57.731Z" itemprop="datePublished">2023-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><span id="more"></span>

<p><u><em><strong>仅用于个人学习，侵删</strong></em></u></p>
<h2 id="1-小册概览"><a href="#1-小册概览" class="headerlink" title="1 小册概览"></a>1 小册概览</h2><p>TCP 的知识浩如烟海，我把自己工作中遇到的最频繁的、觉得最重要的内容抽取了出来，写成了这本小册，大概覆盖了下面这些内容</p>
<ul>
<li>基本概念：TCP 头部、MTU、MSS等概念</li>
<li>TCP 的面向连接、可靠、流协议说的是什么</li>
<li>TCP 的 11 种状态如何模拟以及如何互相转换</li>
<li>如何模拟同时打开、同时关闭</li>
<li>半连接、全连接队列是什么，backlog 参数有什么作用</li>
<li>快速打开的原理是什么</li>
<li>TCP SYN Flood 攻击背后的原理</li>
<li>TCP 最不好理解的 TIME_WAIT 状态是什么</li>
<li>SO_REUSEADDR、SO_LINGER 选项对网络编程有什么影响</li>
<li>TCP 有 7 个定时器是哪些，分别在什么条件下起作用</li>
<li>流量控制、滑动窗口、拥塞控制、快重传、慢启动等概念</li>
<li>keepalive 机制</li>
<li>Nagle 算法、延迟确认的相爱相杀</li>
<li>网络学习相关的工具介绍：telnet、nc、tcpdump、wireshark、lsof、iptables、scapy 等</li>
<li>wireshark 那些难以看懂的提示是什么意思</li>
<li>协议栈测试工具 packetdrill 的使用</li>
<li>如何杀掉一条 TCP 连接</li>
<li>常见网络面试题分析</li>
</ul>
<h2 id="2-TCP-IP-历史与分层模型"><a href="#2-TCP-IP-历史与分层模型" class="headerlink" title="2 TCP/IP 历史与分层模型"></a>2 TCP/IP 历史与分层模型</h2><h3 id="2-1-TCP-IP-网络分层"><a href="#2-1-TCP-IP-网络分层" class="headerlink" title="2.1 TCP/IP 网络分层"></a>2.1 TCP/IP 网络分层</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad5181cb911e12~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/11/16dbb2fbdaebd148~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="2-2-应用层（Application-Layer）"><a href="#2-2-应用层（Application-Layer）" class="headerlink" title="2.2 应用层（Application Layer）"></a>2.2 应用层（Application Layer）</h3><p>HTTP 报文格式由三部分组成：</p>
<ul>
<li>起始行（start line），起始行根据是请求报文还是响应报文分为「请求行」和「响应行」。这个例子中起始行是<code>GET / HTTP/1.1</code>，表示这是一个 <code>GET</code> 请求，请求的 URL 为<code>/</code>，协议版本为<code>HTTP 1.1</code>，起始行最后会有一个空行<code>CRLF（\r\n)</code>与下面的首部分隔开</li>
<li>首部（header），首部采用形如<code>key:value</code>的方式，比如常见的<code>User-Agent</code>、<code>ETag</code>、<code>Content-Length</code>都属于 HTTP 首部，每个首部直接也是用空行分隔</li>
<li>可选的实体（entity），实体是 HTTP 真正要传输的内容，比如下载一个图片文件，传输的一段 HTML等</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad5181c634aed0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="2-3-传输层（Transport-Layer）"><a href="#2-3-传输层（Transport-Layer）" class="headerlink" title="2.3 传输层（Transport Layer）"></a>2.3 传输层（Transport Layer）</h3><p>虽然是叫传输层，但是并不是将数据包从一台主机传送到另一台，而是对「传输行为进行控制」，这本小册介绍的主要内容 TCP 协议就被称为传输控制协议（Transmission Control Protocol），为下面两层协议提供数据包的重传、流量控制、拥塞控制等。</p>
<p>传输层用端口号来标识不同的应用程序，主机收到数据包以后根据目标端口号将数据包传递给对应的应用程序进行处理。</p>
<h3 id="2-4-网络互连层（Internet-Layer）"><a href="#2-4-网络互连层（Internet-Layer）" class="headerlink" title="2.4 网络互连层（Internet Layer）"></a>2.4 网络互连层（Internet Layer）</h3><p>IP 协议是网络层的主要协议，TCP 和 UDP 都是用 IP 协议作为网络层协议。这一层的主要作用是给包加上源地址和目标地址，将数据包传送到目标地址。</p>
<p>IP 协议是一个无连接的协议，也不具备重发机制，这也是 TCP 协议复杂的原因之一就是基于了这样一个「不靠谱」的协议。</p>
<h3 id="2-5-网络访问层（Network-Access-Layer）"><a href="#2-5-网络访问层（Network-Access-Layer）" class="headerlink" title="2.5 网络访问层（Network Access Layer）"></a>2.5 网络访问层（Network Access Layer）</h3><p>网络访问层提供了主机连接到物理网络需要的硬件和相关的协议。</p>
<p>整体的分层图如下图所示</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad5182f90d0bb5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h2 id="3-TCP-概述-——-可靠的、面向连接的、基于字节流、全双工的协议"><a href="#3-TCP-概述-——-可靠的、面向连接的、基于字节流、全双工的协议" class="headerlink" title="3 TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议"></a>3 TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议</h2><p>如果要用一句话来描述 TCP 协议，我想应该是：TCP 是一个可靠的（reliable）、面向连接的（connection-oriented）、基于字节流（byte-stream）、全双工的（full-duplex）协议。</p>
<h3 id="3-1-TCP-是面向连接的协议"><a href="#3-1-TCP-是面向连接的协议" class="headerlink" title="3.1 TCP 是面向连接的协议"></a>3.1 TCP 是面向连接的协议</h3><p>一开始学习 TCP 的时候，我们就被告知 TCP 是面向连接的协议，那什么是面向连接，什么是无连接呢？</p>
<ul>
<li>面向连接（connection-oriented）：面向连接的协议要求正式发送数据之前需要通过「握手」建立一个<strong>逻辑</strong>连接，结束通信时也是通过有序的四次挥手来断开连接。</li>
<li>无连接（connectionless）：无连接的协议则不需要</li>
</ul>
<h3 id="3-2-协议是可靠的"><a href="#3-2-协议是可靠的" class="headerlink" title="3.2 协议是可靠的"></a>3.2 协议是可靠的</h3><p>IP 是一种无连接、不可靠的协议：<strong>它尽最大可能将数据报从发送者传输给接收者，但并不保证包到达的顺序会与它们被传输的顺序一致，也不保证包是否重复，甚至都不保证包是否会达到接收者。</strong></p>
<p><strong>TCP</strong> 要想在 IP 基础上构建可靠的传输层协议，必须有一个复杂的机制来保障可靠性。 主要有下面几个方面：**</p>
<ul>
<li><strong>对每个包提供校验和</strong></li>
<li><strong>包的序列号解决了接收数据的乱序、重复问题</strong></li>
<li><strong>超时重传</strong></li>
<li><strong>流量控制、拥塞控制</strong></li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/9/16dafd4097c7d058~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><strong>校验和（checksum）</strong> 每个 TCP 包首部中都有两字节用来表示校验和，防止在传输过程中有损坏。如果收到一个校验和有差错的报文，TCP 不会发送任何确认直接丢弃它，等待发送端重传。</p>
<p><strong>包的序列号保证了接收数据的乱序和重复问题</strong> 假设我们往 TCP 套接字里写 3000 字节的数据导致 TCP发送了 3 个数据包，每个数据包大小为 1000 字节：第一个包序列号为[1<del>1001)，第二个包序列号为 [1001</del>2001)，第三个包序号为[2001~3001)</p>
<p>假如因为网络的原因导致第二个、第三个包先到接收端，第一个包最后才到，接收端也不会因为他们到达的顺序不一致把包弄错，TCP 会根据他们的序号进行重新的排列然后把结果传递给上层应用程序。</p>
<p>如果 TCP 接收到重复的数据，可能的原因是超时重传了两次但这个包并没有丢失，接收端会收到两次同样的数据，它能够根据包序号丢弃重复的数据。</p>
<p><strong>超时重传</strong> TCP 发送数据后会启动一个定时器，等待对端确认收到这个数据包。如果在指定的时间内没有收到 ACK 确认，就会重传数据包，然后等待更长时间，如果还没有收到就再重传，在多次重传仍然失败以后，TCP 会放弃这个包。后面我们讲到超时重传模块的时候会详细介绍这部分内容。</p>
<p><strong>流量控制、拥塞控制</strong></p>
<h3 id="3-3-TCP-是面向字节流的协议"><a href="#3-3-TCP-是面向字节流的协议" class="headerlink" title="3.3 TCP 是面向字节流的协议"></a>3.3 TCP 是面向字节流的协议</h3><p>TCP 是一种字节流（byte-stream）协议，流的含义是没有固定的报文边界。</p>
<p>假设你调用 2 次 write 函数往 socket 里依次写 500 字节、800 字节。<strong>write 函数只是把字节拷贝到内核缓冲区，最终会以多少条报文发送出去是不确定的。</strong></p>
<p>上面出现的情况取决于诸多因素：<strong>路径最大传输单元 MTU、发送窗口大小、拥塞窗口大小</strong>等。</p>
<p>当接收方从 TCP 套接字读数据时，它是没法得知对方每次写入的字节是多少的。接收端可能分2 次每次 650 字节读取，也有可能先分三次，一次 100 字节，一次 200 字节，一次 1000 字节进行读取。</p>
<h3 id="3-4-TCP-是全双工的协议"><a href="#3-4-TCP-是全双工的协议" class="headerlink" title="3.4 TCP 是全双工的协议"></a>3.4 TCP 是全双工的协议</h3><p>在 TCP 中发送端和接收端可以是客户端/服务端，也可以是服务器/客户端，通信的双方在任意时刻既可以是接收数据也可以是发送数据，每个方向的数据流都独立管理序列号、滑动窗口大小、MSS 等信息。</p>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/20/16ad518763d230b6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h2 id="4-支撑-TCP-协议的基石-——-剖析首部字段"><a href="#4-支撑-TCP-协议的基石-——-剖析首部字段" class="headerlink" title="4 支撑 TCP 协议的基石 —— 剖析首部字段"></a>4 支撑 TCP 协议的基石 —— 剖析首部字段</h2><h3 id="4-1-源端口号、目标端口号"><a href="#4-1-源端口号、目标端口号" class="headerlink" title="4.1 源端口号、目标端口号"></a>4.1 源端口号、目标端口号</h3><p>TCP 报文头部里没有源 ip 和目标 ip 地址，只有源端口号和目标端口号</p>
<p>这也是初学 wireshark 抓包时很多人会有的一个疑问：过滤 ip 地址为 172.19.214.24 包的条件为什么不是 “tcp.addr == 172.19.214.24”，而是 “ip.addr == 172.19.214.24”</p>
<p><strong>TCP 的报文里是没有源 ip 和目标 ip 的，因为那是 IP 层协议的事情，TCP 层只有源端口和目标端口。</strong></p>
<p><strong>源 IP、源端口、目标 IP、目标端口构成了 TCP 连接的「四元组」。一个四元组可以唯一标识一个连接。</strong></p>
<p>后面文章中专门有一节是用来介绍端口号相关的知识。</p>
<h3 id="4-2-序列号（Sequence-number）"><a href="#4-2-序列号（Sequence-number）" class="headerlink" title="4.2 序列号（Sequence number）"></a>4.2 序列号（Sequence number）</h3><p>TCP 是面向字节流的协议，通过 TCP 传输的字节流的每个字节都分配了序列号，序列号（Sequence number）指的是本报文段第一个字节的序列号。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d658980af614477296e95ae5f3f658f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>序列号加上报文的长度，就可以确定传输的是哪一段数据。序列号是一个 32 位的无符号整数，达到 2^32-1 后循环到 0。</p>
<p>在 SYN 报文中，序列号用于交换彼此的初始序列号，在其它报文中，序列号用于保证包的顺序。</p>
<p>因为网络层（IP 层）不保证包的顺序，TCP 协议利用序列号来解决网络包乱序、重复的问题，以保证数据包以正确的顺序组装传递给上层应用。</p>
<p>如果发送方发送的是四个报文序列号分别是1、2、3、4，但到达接收方的顺序是 2、4、3、1，接收方就可以通过序列号的大小顺序组装出原始的数据。</p>
<h3 id="4-3-初始序列号（Initial-Sequence-Number-ISN）"><a href="#4-3-初始序列号（Initial-Sequence-Number-ISN）" class="headerlink" title="4.3 初始序列号（Initial Sequence Number, ISN）"></a>4.3 初始序列号（Initial Sequence Number, ISN）</h3><p>在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。在建立连接时，通信双方通过 SYN 报文交换彼此的 ISN，如下图所示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b57f577bc8b460fbf804c728538d230~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>初始建立连接的过程中 SYN 报文交换过程如下图所示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/649f7216e18147ee9411d1424fd71792~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><strong>其中第 2 步和第 3 步可以合并一起，这就是三次握手的过程（下图重要）</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d499ad8e97c4c48942e39a7bd195652~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="4-4-确认号"><a href="#4-4-确认号" class="headerlink" title="4.4 确认号"></a>4.4 确认号</h3><p>TCP 使用确认号（Acknowledgment number, ACK）来告知对方下一个期望接收的序列号，小于此确认号的所有字节都已经收到。</p>
<p>关于确认号有几个注意点：</p>
<ul>
<li>不是所有的包都需要确认的</li>
<li>不是收到了数据包就立马需要确认的，可以延迟一会再确认</li>
<li>ACK 包本身不需要被确认，否则就会无穷无尽死循环了</li>
<li>确认号永远是表示小于此确认号的字节都已经收到</li>
</ul>
<h3 id="4-5-TCP-Flags"><a href="#4-5-TCP-Flags" class="headerlink" title="4.5 TCP Flags"></a>4.5 TCP Flags</h3><p>TCP 有很多种标记，有些用来发起连接同步初始序列号，有些用来确认数据包，还有些用来结束连接。TCP 定义了一个 8 位的字段用来表示 flags，大部分都只用到了后 6 个，如下图所示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59260fc36dfa468693085a6ac4600448~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>我们通常所说的 SYN、ACK、FIN、RST 其实只是把 flags 对应的 bit 位置为 1 而已，这些标记可以组合使用，比如 SYN+ACK，FIN+ACK 等</p>
<p><strong>最常见的有下面这几个：</strong></p>
<ul>
<li><strong>SYN（Synchronize）：用于发起连接数据包同步双方的初始序列号</strong></li>
<li><strong>ACK（Acknowledge）：确认数据包</strong></li>
<li><strong>RST（Reset）：这个标记用来强制断开连接，通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理</strong></li>
<li><strong>FIN（Finish）：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。</strong></li>
<li><strong>PSH（Push）：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来</strong></li>
</ul>
<h3 id="4-6-窗口大小"><a href="#4-6-窗口大小" class="headerlink" title="4.6 窗口大小"></a>4.6 窗口大小</h3><p>可以看到用于表示窗口大小的”Window Size” 只有 16 位，可能 TCP 协议设计者们认为 16 位的窗口大小已经够用了，也就是最大窗口大小是 65535 字节（64KB）。就像网传盖茨曾经说过：“640K内存对于任何人来说都足够了”一样。</p>
<p>自己挖的坑当然要自己填，因此TCP 协议引入了「TCP 窗口缩放」选项 作为窗口缩放的比例因子，比例因子值的范围是 0 ~ 14，其中最小值 0 表示不缩放，最大值 14。比例因子可以将窗口扩大到原来的 2 的 n 次方，比如窗口大小缩放前为 1050，缩放因子为 7，则真正的窗口大小为 1050 * 128 = 134400，如下图所示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16a4bb980c144a5ea9e2f6cf86360d92~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>值得注意的是，窗口缩放值在三次握手的时候指定，如果抓包的时候没有抓到 三次握手阶段的包，wireshark 是不知道真正的窗口缩放值是多少的。</p>
<h2 id="6-数据包大小对网络的影响-——-MTU-与-MSS-的奥秘"><a href="#6-数据包大小对网络的影响-——-MTU-与-MSS-的奥秘" class="headerlink" title="6 数据包大小对网络的影响 —— MTU 与 MSS 的奥秘"></a>6 数据包大小对网络的影响 —— MTU 与 MSS 的奥秘</h2><p>前面的文章中介绍过一个应用层的数据包会经过传输层、网络层的层层包装，交给网络接口层传输。<strong>假设上层的应用调用 write 等函数往 socket 写入了 10KB 的数据，TCP 会如何处理呢？是直接加上 TCP 头直接交给网络层吗？</strong>这篇文章我们来讲讲这相关的知识：</p>
<h3 id="6-1-最大传输单元（Maximum-Transmission-Unit-MTU）"><a href="#6-1-最大传输单元（Maximum-Transmission-Unit-MTU）" class="headerlink" title="6.1 最大传输单元（Maximum Transmission Unit, MTU）"></a>6.1 最大传输单元（Maximum Transmission Unit, MTU）</h3><p>数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」</p>
<p>下图是以太网的帧格式，以太网的帧最小的帧是 64 字节，除去 14 字节头部和 4 字节 CRC 字段，有效荷载最小为 46 字节。最大的帧是 1518 字节，除去 14 字节头部和 4 字节 CRC，有效荷载最大为 1500，这个值就是以太网的 MTU。因此如果传输 100KB 的数据，至少需要 （100 * 1024 / 1500) = 69 个以太网帧。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e260cd0cd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>不同的数据链路层的 MTU 是不同的。通过<code>netstat -i</code> 可以查看网卡的 mtu，比如在 我的 centos 机器上可以看到</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e147f6672~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="6-2-IP-分段"><a href="#6-2-IP-分段" class="headerlink" title="6.2 IP 分段"></a>6.2 IP 分段</h3><p>IPv4 数据报的最大大小为 65535 字节，这已经远远超过了以太网的 MTU，而且有些网络还会开启巨帧（Jumbo Frame）能达到 9000 字节。 当一个 IP 数据包大于 MTU 时，IP 会把数据报文进行切割为多个小的片段(小于 MTU），使得这些小的报文可以通过链路层进行传输。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ping -s 3000 www.baidu.com</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">PING www.a.shifen.com (14.215.177.39): 3000 data bytes</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br></pre></td></tr></table></figure>

<p>先看第一个包</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e4ee94a57~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>这个包是 IP 分段包的第一个分片，<code>More fragments: Set</code>表示这个包是 IP 分段包的一部分，还有其它的分片包，<code>Fragment offset: 0</code>表示分片偏移量为 0，IP 包的 payload 的大小为 1480，加上 20 字节的头部正好是 1500。</p>
<p>第二个包的详情截图如下</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e4dcc0174~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>同样<code>More fragments</code>处于 set 状态，表示后面还有其它分片，<code>Fragment offset: 185</code>这里并不是表示分片偏移量为 185，wireshark 这里显示的时候除以了 8，真实的分片偏移量为 185 * 8 = 1480。</p>
<p>第三个包的详情截图如下 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e51db4162~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>可以看到<code>More fragments</code>处于 Not set 状态，表示这是最后一个分片了。<code>Fragment offset: 370</code>表示偏移量为 370 * 8 = 2960，包的大小为 68 - 20（IP 头部大小） = 48。</p>
<p>三个分片如下图所示</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e54362613~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>前面我们提到 IP 协议不会对丢包进行重传，那么 IP 分段中有分片丢失、损坏的话，会发生什么呢？ <strong>这种情况下，目标主机将没有办法将分段的数据包重组为一个完整的数据包，依赖于传输层是否进行重传。</strong></p>
<p><strong>利用 IP 包分片的策略，有一种对应的网络攻击方式<code>IP fragment attack</code>，就是一直传<code>More fragments = 1</code>的包，导致接收方一直缓存分片，从而可能导致接收方内存耗尽。</strong></p>
<h3 id="6-3-网络中的木桶效应：路径-MTU"><a href="#6-3-网络中的木桶效应：路径-MTU" class="headerlink" title="6.3 网络中的木桶效应：路径 MTU"></a>6.3 网络中的木桶效应：路径 MTU</h3><p>一个包从发送端传输到接收端，中间要跨越很多个网络，每条链路的 MTU 都可能不一样，这个通信过程中最小的 MTU 称为「路径 MTU（Path MTU）」。就好比开车有时候开的是双向 4 车道，有时候可能是乡间小路一样。</p>
<p>比如下图中，第一段链路 MTU 大小为 1500 字节，第二段链路 MTU 为 800 字节，第三段链路 MTU 为 1200 字节，则路径 MTU 为三段 MTU 的最小值 800。</p>
<p>路径 MTU 就跟木桶效应是一个道理，木桶的盛水量由最短的那条短板决定，路径 MTU 也是由通信链条中最小的 MTU 决定。</p>
<p>补充：<strong>ICMP报文</strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ICMP&spm=1001.2101.3001.7020">ICMP</a>的功能是检错而不是纠错；</strong></p>
<p><strong>它将出错的报文返回给发送方的设备，发送方根据<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ICMP%E6%8A%A5%E6%96%87&spm=1001.2101.3001.7020">ICMP报文</a>确定「错误类型」，从而更好的重发错误的数据包。</strong></p>
<p><strong>我们用来测试网络连通性的 ping 命令，就是ICMP的工作过程。</strong></p>
<h3 id="6-4-实际模拟路径-MTU-发现"><a href="#6-4-实际模拟路径-MTU-发现" class="headerlink" title="6.4 实际模拟路径 MTU 发现"></a>6.4 实际模拟路径 MTU 发现</h3><p>其中在发送了 1460 大小的数据以后，这第一个数据包在 IP 层设置了不分段，之后收到一个 ICMP 告知的报文过大错误</p>
<p>运行抓包如下图</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e84446756~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>1 ~ 3：三次握手</li>
<li>4：发送长度为 1460 的数据，这个数据包设置了不允许分片<code>Don&#39;t fragment: Set</code></li>
<li>5：<strong>发送端收到 ICMP 包，告知包太大需要分片，下一个分片的大小按照 MTU=1200 来计算</strong> <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e81b1e6df~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></li>
<li>6：<strong>TCP 为了避免底层分片立刻拆包重发数据包，这次包大小为 1200 - 40 = 1160</strong></li>
<li>7：发送端发送剩下的 300 字节（1460 - 1160）</li>
<li>8：确认所有的数据</li>
</ul>
<p>整个过程如下图所示 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e887eea11~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><strong>因为有 MTU 的存在，TCP 每次发包的大小也限制了，这就是下面要介绍的 MSS。</strong></p>
<h3 id="6-5-TCP-最大段大小（Max-Segment-Size，MSS）"><a href="#6-5-TCP-最大段大小（Max-Segment-Size，MSS）" class="headerlink" title="6.5 TCP 最大段大小（Max Segment Size，MSS）"></a>6.5 TCP 最大段大小（Max Segment Size，MSS）</h3><p><strong>TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MSS</span> = MTU - IP header头大小 - TCP 头大小</span><br></pre></td></tr></table></figure>

<p>这样一个 MSS 的数据恰好能装进一个 MTU 而不用分片。</p>
<p><strong>在以太网中 TCP 的 MSS = 1500（MTU） - 20（IP 头大小） - 20（TCP 头大小）= 1460。</strong></p>
<p>我们来抓一个包来实际看一下，下面是下载一个 png 图片的 http 请求包 当三次握手建立一个 TCP 连接时，通信的双方会在 SYN 报文里说明自己允许的最大段大小。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/3/1700a73e8a06ec69~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>可以看到 TCP 的包体数据大小为 1448，因为TCP 头部里包含了 12 字节的选项（Options）字段，头部大小从之前的 20 字节变为了 32 字节，所以 TCP 包体大小变为了：1500（以太网 MTU） - 20（IP 固定表头大小） - 20（TCP 固定表头大小） - 12（TCP 表头选项） = 1448</p>
<h3 id="6-6-为什么有时候抓包看到的单个数据包大于-MTU"><a href="#6-6-为什么有时候抓包看到的单个数据包大于-MTU" class="headerlink" title="6.6 为什么有时候抓包看到的单个数据包大于 MTU"></a>6.6 为什么有时候抓包看到的单个数据包大于 MTU</h3><p>这就要说到 TSO（TCP Segment Offload）特性了，TSO 特性是指由网卡代替 CPU 实现 packet 的分段和合并，节省系统资源，因此 TCP 可以抓到超过 MTU 的包，但是不是真正传输的单个包会超过链路的 MTU。</p>
<h2 id="7-繁忙的贸易港口-——-聊聊端口号"><a href="#7-繁忙的贸易港口-——-聊聊端口号" class="headerlink" title="7 繁忙的贸易港口 —— 聊聊端口号"></a>7 繁忙的贸易港口 —— 聊聊端口号</h2><p>分层结构中每一层都有一个唯一标识，比如链路层的 MAC 地址，IP 层的 IP 地址，传输层是用端口号。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134ba7385716~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>TCP 用两字节的整数来表示端口，一台主机最大允许 65536 个端口号的。TCP 首部中端口号如下图黄色高亮部分。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134ba78527c6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><strong>有了 IP 协议，数据包可以顺利的被传输到对应 IP 地址的主机</strong>，当主机收到一个数据包时，应该把这个数据包交给哪个应用程序进行处理呢？<strong>传输层就是用端口号来区分同一个主机上不同的应用程序的。</strong>操作系统为有需要的进程分配端口号，当目标主机收到数据包以后，会根据数据报文首部的目标端口号将数据发送到对应端口的进程。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134ba7638486~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="7-1-端口相关命令"><a href="#7-1-端口相关命令" class="headerlink" title="7.1 端口相关命令"></a>7.1 端口相关命令</h3><h4 id="（1）如何查看对方端口是否打开"><a href="#（1）如何查看对方端口是否打开" class="headerlink" title="（1）如何查看对方端口是否打开"></a>（1）如何查看对方端口是否打开</h4><p>使用 nc 和 telnet 这两个命令可以非常方便的查看到对方端口是否打开或者网络是否可达，比如查看 10.211.55.12 机器的 6379 端口是否打开可以使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">telnet 10.211.55.12 6379                                                                                                                                     </span><br><span class="line">Trying 10.211.55.12...</span><br><span class="line">Connected to 10.211.55.12.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nc -v  10.211.55.12 6379                                                                                                                                    </span><br><span class="line">Ncat: Connected to 10.211.55.12:6379</span><br></pre></td></tr></table></figure>

<p>这两个命令我后面会有独立的内容来介绍，现在先有一个印象。</p>
<p>如果对端端口没有打开，会发生什么呢？比如 10.211.55.12 的6380 端口没有打开，使用 telnet 和 nc 命令会出现 “Connection refused” 错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">telnet  10.211.55.12 6380                                                                                                                                     </span><br><span class="line">Trying 10.211.55.12...</span><br><span class="line">telnet: connect to address 10.211.55.12: Connection refused</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nc -v  10.211.55.12 6380                             </span><br></pre></td></tr></table></figure>

<h4 id="（2）如何查看端口被什么进程监听占用"><a href="#（2）如何查看端口被什么进程监听占用" class="headerlink" title="（2）如何查看端口被什么进程监听占用"></a>（2）如何查看端口被什么进程监听占用</h4><p>比如查看 22 端口被谁占用，常见的可以使用 lsof 和 netstat 两种方法</p>
<p><strong>第一种方法：使用 netstat</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -ltpn | grep :22</span><br></pre></td></tr></table></figure>

<p><strong>第二种方法：使用 lsof</strong> 因为在 linux 上一切皆文件，TCP socket 连接也是一个 fd。因此使用 lsof 也可以</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -n -<span class="selector-tag">P</span> -<span class="selector-tag">i</span>:<span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>-n</code> 表示不将 IP 转换为 hostname，<code>-P</code> 表示不将 port number 转换为 service name，<code>-i:port</code> 表示端口号为 22 的进程</p>
<h4 id="（3）反过来，如何查看进程监听或者打开了哪些端口呢？"><a href="#（3）反过来，如何查看进程监听或者打开了哪些端口呢？" class="headerlink" title="（3）反过来，如何查看进程监听或者打开了哪些端口呢？"></a>（3）反过来，如何查看进程监听或者打开了哪些端口呢？</h4><p>还是以 sshd 为例，先用<code>ps -ef | grep sshd</code> 找到 sshd 的进程号，这里为 1333</p>
<p><strong>第一种方法：使用 netstat</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -atpn | <span class="keyword">grep</span> <span class="number">1333</span></span><br></pre></td></tr></table></figure>

<p><strong>第二种方法：使用 lsof</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -n -<span class="selector-tag">P</span> -<span class="selector-tag">p</span> <span class="number">1333</span> | grep TCP</span><br></pre></td></tr></table></figure>

<p><strong>第三种方法奇技淫巧：/proc/pid</strong></p>
<p>在 linux 上有一个神奇的目录<code>/proc</code>，每个进程启动以后会生成这样一个目录，比如我们用<code>nc -4 -l 8080</code>快速启动一个 tcp 的服务器，使用 ps 找到进程 id</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | <span class="keyword">grep</span> <span class="string">&quot;nc -4 -l 8080&quot;</span> | <span class="keyword">grep</span> -v <span class="keyword">grep</span></span><br><span class="line"></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">ya       <span class="number">19196</span> <span class="number">15191</span>  <span class="number">0</span> <span class="number">00</span>:<span class="number">33</span> pts/<span class="number">6</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> nc -<span class="number">4</span> -l <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p><img src="https://yygh-testosscjf.oss-cn-beijing.aliyuncs.com/40.png" alt="40"></p>
<p>fd 为 0，1，2的分别表示标准输入stdin(0)、标准输出stdout(1)、错误输出stderr(2)。fd 为 3 表示 nc 监听的套接字 fd，后面跟了一个神奇的数字 25597827，这个数字表示 socket 的 inode 号，我们可以通过这个 inode 号来找改 socket 的信息。</p>
<p>TCP 的连接信息会在这里显示<code>cat /proc/net/tcp</code></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134be85cf9f1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>可以找到 inode 为 25597827 的套接字。其中 local_address 为 00000000:1F90，rem_address 为 00000000:0000，表示四元组（0.0.0.0:8080, 0.0.0.0:0)，state 为 0A，表示 TCP_LISTEN 状态。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b9134c2146ce36~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h2 id="8-TCP-恋爱史第一步-——-从三次握手说起"><a href="#8-TCP-恋爱史第一步-——-从三次握手说起" class="headerlink" title="8 TCP 恋爱史第一步 —— 从三次握手说起"></a>8 TCP 恋爱史第一步 —— 从三次握手说起</h2><h3 id="8-1-三次握手"><a href="#8-1-三次握手" class="headerlink" title="8.1 三次握手"></a>8.1 三次握手</h3><p>一次经典的三次握手的过程如下图所示： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518ccedac1b6e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>三次握手的最重要的是交换彼此的 ISN（初始序列号），序列号怎么计算来的可以暂时不用深究，我们需要重点掌握的是包交互过程中序列号变化的原理。</p>
<p>1、客户端发送的一个段是 SYN 报文，这个报文只有 SYN 标记被置位。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518cceddbdcf6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> SYN 报文不携带数据，但是它占用一个序号，下次发送数据序列号要加一。客户端会随机选择一个数字作为初始序列号（ISN）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么 SYN 段不携带数据却要消耗一个序列号呢？</span><br></pre></td></tr></table></figure>

<p>这是一个好问题，<strong>不占用序列号的段是不需要确认的（都没有内容确认个啥）</strong>，比如 ACK 段。SYN 段需要对方的确认，需要占用一个序列号。后面讲到四次挥手那里 FIN 包也有同样的情况，在那里我们会用一个图来详细说明。</p>
<p>关于这一点，可以记住如下的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">凡是消耗序列号的 TCP 报文段，一定需要对端确认。如果这个段没有收到确认，会一直重传直到达到指定的次数为止。</span><br></pre></td></tr></table></figure>

<p><em><strong><u>上图非常重要</u></strong></em></p>
<p>2、服务端收到客户端的 SYN 段以后，将 SYN 和 ACK 标记都置位</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518ccee187690~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>SYN 标记的作用与步骤 1 中的一样，也是同步服务端生成的初始序列号。ACK 用来告知发送端之前发送的 SYN 段已经收到了，「确认号」字段指定了发送端下次发送段的序号，这里等于客户端 ISN 加一。 与前面类似 SYN + ACK 端虽然没有携带数据，但是因为 SYN 段需要被确认，所以它也要消耗一个序列号。</p>
<p>3、客户端发送三次握手最后一个 ACK 段，这个 ACK 段用来确认收到了服务端发送的 SYN 段。因为这个 ACK 段不携带任何数据，且不需要再被确认，这个 ACK 段不消耗任何序列号。</p>
<p>一个最简单的三次握手过程的wireshark 抓包如下： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518ccee4d8711~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>除了交换彼此的初始序列号，三次握手的另一个重要作用是交换一些辅助信息，比如最大段大小（MSS）、窗口大小（Win）、窗口缩放因子（WS)、是否支持选择确认（SACK_PERM）等，这些都会在后面的文章中重点介绍。</p>
<h3 id="8-2-初始序列号（Initial-Sequence-Number-ISN）"><a href="#8-2-初始序列号（Initial-Sequence-Number-ISN）" class="headerlink" title="8.2 初始序列号（Initial Sequence Number, ISN）"></a>8.2 初始序列号（Initial Sequence Number, ISN）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISN 能设置成一个固定值呢？</span><br></pre></td></tr></table></figure>

<p>答案是不能，TCP 连接四元组（源 IP、源端口号、目标 IP、目标端口号）唯一确定，所以就算所有的连接 ISN 都是一个固定的值，连接之间也是不会互相干扰的。但是会有几个严重的问题</p>
<p>1、出于安全性考虑。如果被知道了连接的ISN，很容易构造一个在对方窗口内的序列号，源 IP 和源端口号都很容易伪造，这样一来就可以伪造 RST 包，将连接强制关闭掉了。如果采用动态增长的 ISN，要想构造一个在对方窗口内的序列号难度就大很多了。</p>
<p>2、因为开启 SO_REUSEADDR 以后端口允许重用，收到一个包以后不知道新连接的还是旧连接的包因为网络的原因姗姗来迟，造成数据的混淆。如果采用动态增长的 ISN，那么可以保证两个连接的 ISN 不会相同，不会串包。</p>
<h3 id="8-3-三次握手的状态变化"><a href="#8-3-三次握手的状态变化" class="headerlink" title="8.3 三次握手的状态变化"></a>8.3 三次握手的状态变化</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/13/16b518cd1664fa5d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="8-4-小结"><a href="#8-4-小结" class="headerlink" title="8.4 小结"></a>8.4 小结</h3><p>这篇文章主要介绍了三次握手的相关的内容，我们来回顾一下。</p>
<p>首先介绍了三次握手交换 ISN 的细节：</p>
<ul>
<li>SYN 段长度为 0 却需要消耗一个序列号，原因是 SYN 段需要对端确认</li>
<li>ACK 段长度为 0，不消耗序列号，也不用对端确认</li>
<li>ISN 不能从一个固定的值开始，原因是处于安全性和避免前后连接互相干扰</li>
</ul>
<p>接下来首次介绍了 TCP 的状态机，TCP 的这 11 中状态的变化是 TCP 学习的重中之重。</p>
<p>接下来用 packetdrill 轻松构造了一个 SYN_SENT 状态的 TCP 连接，随后通过这个例子介绍了这本小册第一个 TCP 定时器「连接建立定时器」，这个定时器会在发送第一个 SYN 包以后开启，如果没有收到对端 ACK，会重传指定的次数。</p>
<p>最后我们介绍了同时打开这种比较罕见的建立连接的方式。</p>
<h2 id="9-相见时难别亦难-——-谈谈四次挥手"><a href="#9-相见时难别亦难-——-谈谈四次挥手" class="headerlink" title="9 相见时难别亦难 —— 谈谈四次挥手"></a>9 相见时难别亦难 —— 谈谈四次挥手</h2><h3 id="9-1-四次挥手"><a href="#9-1-四次挥手" class="headerlink" title="9.1 四次挥手"></a>9.1 四次挥手</h3><p>最常见的四次挥手的过程下图所示</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c618264239~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>1、客户端调用 <code>close</code> 方法，执行「主动关闭」，会发送一个 FIN 报文给服务端，从这以后客户端不能再发送数据给服务端了，客户端进入<code>FIN-WAIT-1</code>状态。FIN 报文其实就是将 FIN 标志位设置为 1。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c69b0f0f8e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><strong>FIN 段是可以携带数据的，比如客户端可以在它最后要发送的数据块可以“捎带” FIN 段。当然也可以不携带数据。不管 FIN 段是否携带数据，都需要消耗一个序列号。</strong></p>
<p>客户端发送 FIN 包以后不能再发送数据给服务端，但是还可以接受服务端发送的数据。这个状态就是所谓的「半关闭（half-close）」</p>
<p>主动发起关闭的一方称为「主动关闭方」，另外一方称为「被动关闭方」。</p>
<p>2、服务端收到 FIN 包以后回复确认 ACK 报文给客户端，服务端进入 <code>CLOSE_WAIT</code>，客户端收到 ACK 以后进入<code>FIN-WAIT-2</code>状态。</p>
<p>3、服务端也没有数据要发送了，发送 FIN 报文给客户端，然后进入<code>LAST-ACK</code> 状态，等待客户端的 ACK。同前面一样如果 FIN 段没有携带数据，也需要消耗一个序列号。</p>
<p>4、客户端收到服务端的 FIN 报文以后，回复 ACK 报文用来确认第三步里的 FIN 报文，进入<code>TIME_WAIT</code>状态，等待 2 个 MSL 以后进入 <code>CLOSED</code>状态。服务端收到 ACK 以后进入<code>CLOSED</code>状态。<code>TIME_WAIT</code>是一个很神奇的状态，后面有文章会专门介绍。</p>
<h3 id="9-2-为什么-FIN-报文要消耗一个序列号"><a href="#9-2-为什么-FIN-报文要消耗一个序列号" class="headerlink" title="9.2 为什么 FIN 报文要消耗一个序列号"></a>9.2 为什么 FIN 报文要消耗一个序列号</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c61961ba78~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>如上图所示，如果 FIN 包不消耗一个序列号。客户端发送了 100 字节的数据包和 FIN 包，都等待服务端确认。如果这个时候客户端收到了ACK=1000 的确认包，就无法得知到底是 100 字节的确认包还是 FIN 包的确认包。</p>
<h3 id="9-3-为什么挥手要四次，变为三次可以吗？"><a href="#9-3-为什么挥手要四次，变为三次可以吗？" class="headerlink" title="9.3 为什么挥手要四次，变为三次可以吗？"></a>9.3 为什么挥手要四次，变为三次可以吗？</h3><p>首先我们先明确一个问题，TCP 连接终止一定要四次包交互吗？三次可以吗？</p>
<p>当然可以，因为有<strong>延迟确认</strong>的存在，把第二步的 ACK 经常会跟随第三步的 FIN 包一起捎带会对端。延迟确认后面有一节专门介绍。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/30/16e1a9da7d44c03d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>其实这个行为跟应用层有比较大的关系，因为发送 FIN 包以后，会进入半关闭（half-close）状态，表示自己不会再给对方发送数据了。因此如果服务端收到客户端发送的 FIN 包以后，只能表示客户端不会再给自己发送数据了，但是服务端这个时候是可以给客户端发送数据的。</p>
<p><em><strong>在这种情况下，如果不及时发送 ACK 包，死等服务端这边发送数据，可能会造成客户端不必要的重发 FIN 包</strong></em>，如下图所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c69a12791c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><em><strong>如果服务端确定没有什么数据需要发给客户端，那么当然是可以把 FIN 和 ACK 合并成一个包，四次挥手的过程就成了三次。</strong></em></p>
<h3 id="9-4-握手可以变为四次吗？"><a href="#9-4-握手可以变为四次吗？" class="headerlink" title="9.4 握手可以变为四次吗？"></a>9.4 握手可以变为四次吗？</h3><p><strong>其实理论上完全是可以的，把三次握手的第二次的 SYN+ACK 拆成先回 ACK 包，再发 SYN 包就变成了「四次握手」</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/26/16b911c6a3ca620d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>与 FIN 包不同的是，一般情况下，SYN 包都不携带数据，收到客户端的 SYN 包以后不用等待，可以立马回复 SYN+ACK，四次握手理论上可行，但是现实中我还没有见过。</p>
<h2 id="11-时光机-——-TCP-头部时间戳选项"><a href="#11-时光机-——-TCP-头部时间戳选项" class="headerlink" title="11 时光机 —— TCP 头部时间戳选项"></a>11 时光机 —— TCP 头部时间戳选项</h2><h3 id="11-1-Timestamps-选项是什么"><a href="#11-1-Timestamps-选项是什么" class="headerlink" title="11.1 Timestamps 选项是什么"></a>11.1 Timestamps 选项是什么</h3><p>除了我们之前介绍的 MSS、Window Scale 还有以一个非常重要的选项：时间戳（TCP Timestamps Option，TSopt）。这个选项在 TCP 头部的位置如下所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c5c635f86~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="11-2-Timestamps-选项的组成部分"><a href="#11-2-Timestamps-选项的组成部分" class="headerlink" title="11.2 Timestamps 选项的组成部分"></a>11.2 Timestamps 选项的组成部分</h3><p>在 Wireshark 抓包中，常常会看到 TSval 和 TSecr 两个选项，值得注意的是第二个选项 TSecr 不是 secrets 的意思，而是 “TS Echo Reply” 的缩写，TSval 和 TSecr 是 TCP 选项时间戳的一部分。</p>
<p>TCP Timestamps Option 由四部分构成：类别（kind）、长度（Length）、发送方时间戳（TS value）、回显时间戳（TS Echo Reply）。时间戳选项类别（kind）的值等于 8，用来与其它类型的选项区分。长度（length）等于 10。两个时间戳相关的选项都是 4 字节。</p>
<p>如下图所示： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4be8611658~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>是否使用时间戳选项是在三次握手里面的 SYN 报文里面确定的。下面的包是<code>curl github.com</code>抓包得到的结果。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4be8843d80~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>发送方发送数据时，将一个发送时间戳 1734581141 放在发送方时间戳<code>TSval</code>中</li>
<li>接收方收到数据包以后，将收到的时间戳 1734581141 原封不动的返回给发送方，放在<code>TSecr</code>字段中，同时把自己的时间戳 3303928779 放在<code>TSval</code>中</li>
<li>后面的包以此类推</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c5c7ae349~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="11-3-Timestamps-选项的作用"><a href="#11-3-Timestamps-选项的作用" class="headerlink" title="11.3 Timestamps 选项的作用"></a>11.3 Timestamps 选项的作用</h3><p>Timestamps 选项的提出初衷是为了解决两个问题：</p>
<p>1、两端往返时延测量（RTTM）</p>
<p>2、序列号回绕（PAWS），接下来我们来进行介绍。</p>
<h3 id="11-4-PAWS"><a href="#11-4-PAWS" class="headerlink" title="11.4 PAWS"></a>11.4 PAWS</h3><p>Timestamps 选项带来的第二个作用是帮助判断 PAWS，TCP 的序列号用 32bit 来表示，因此在 2^32 字节的数据传输后序列号就会溢出回绕。TCP 的窗口经过窗口缩放可以最高到 1GB（2^30)，在高速网络中，序列号在很短的时间内就会被重复使用。</p>
<p>下面以一个实际的例子来说明，如下图所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/17102ef66f71cbd6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="paws"></p>
<p>假设发送了 6 个数据包，每个数据包的大小为 1GB，第 5 个包序列号发生回绕。第 2 个包因为某些原因延迟导致重传，但没有丢失到时间 t7 才到达。这个迷途数据包与后面要发送的第 6 个包序列号完全相同，如果没有一些措施进行区分，将会造成数据的紊乱。</p>
<p><strong>如果有 Timestamps 的存在，内核会维护一个为每个连接维护一个 ts_recent 值，记录最后一次通信的的 timestamps 值，在 t7 时间点收到迷途数据包 2 时，由于数据包 2 的 timestamps 值小于 ts_recent 值，就会丢弃掉这个数据包。等 t8 时间点真正的数据包 6 到达以后，由于数据包 6 的 timestamps 值大于 ts_recent，这个包可以被正常接收。</strong></p>
<h3 id="11-5-补充说明"><a href="#11-5-补充说明" class="headerlink" title="11.5 补充说明"></a>11.5 补充说明</h3><p>有几个需要说明的点</p>
<ul>
<li><strong>timestamps 值是一个单调递增的值，与我们所知的 epoch 时间戳不是一回事，这个选项不要求两台主机进行时钟同步。</strong>两端 timestamps 值增加的间隔也可能步调不一致，比如一条主机以每 1ms 加一的方式递增，另外一条主机可以以每 1s 加一的方式递增。</li>
<li>与序列号一样，既然是递增 timestamps 值也是会溢出回绕的。</li>
<li>timestamps 是一个双向的选项，如果只要有一方不开启，双方都将停用 timestamps。比如下面是<code>curl www.baidu.com</code>得到的包。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c6e0a8f69~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>可以看到客户端发起 SYN 包时带上了自己的 TSval，服务器回复的 SYN+ACK 包没有 TSval和TSecr，从此之后的包都没有带上时间戳选项了。</p>
<h2 id="13-状态机魔鬼-——-TCP-11-种状态变迁及模拟重现"><a href="#13-状态机魔鬼-——-TCP-11-种状态变迁及模拟重现" class="headerlink" title="13 状态机魔鬼 —— TCP 11 种状态变迁及模拟重现"></a>13 状态机魔鬼 —— TCP 11 种状态变迁及模拟重现</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/22/16b7c9fb02bff057~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><strong>1、CLOSED</strong></p>
<p>这个状态是一个「假想」的状态，是 TCP 连接还未开始建立连接或者连接已经彻底释放的状态。因此<code>CLOSED</code>状态也无法通过 <code>netstat</code> 或者 <code>ss</code> 等工具看到。</p>
<p>从图中可以看到，从 CLOSE 状态转换为其它状态有两种可能：主动打开（Active Open）和被动打开（Passive Open）</p>
<ul>
<li>被动打开：一般来说，服务端会监听一个特定的端口，等待客户端的新连接，同时会进入<code>LISTEN</code>状态，这种被称为「被动打开」</li>
<li>主动打开：客户端主动发送一个<code>SYN</code>包准备三次握手，被称为「主动打开（Active Open）」</li>
</ul>
<p><strong>2、LISTEN</strong></p>
<p>一端（通常是服务端）调用 bind、listen 系统调用监听特定端口时进入到<code>LISTEN</code>状态，等待客户端发送 <code>SYN</code> 报文三次握手建立连接。</p>
<p>在 Java 中只用一行代码就可以构造一个 listen 状态的 socket。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br></pre></td></tr></table></figure>

<p><strong>ServerSocket 的构造器函数最终调用了 bind、listen，接下来就可以调用 accept 接收客户端连接请求了。</strong></p>
<p><strong>使用 netstat 进行查看</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnpa | grep -i 9999                     </span><br><span class="line">tcp6       0      0 :::9999     :::*                    LISTEN      20096/java       </span><br></pre></td></tr></table></figure>

<p>处于<code>LISTEN</code>状态的连接收到<code>SYN</code>包以后会发送 <code>SYN+ACK</code> 给对端，同时进入<code>SYN-RCVD</code>阶段</p>
<p><strong>3、SYN-SENT</strong></p>
<p>客户端发送 <code>SYN</code> 报文等待 <code>ACK</code> 的过程进入 <code>SYN-SENT</code>状态。同时会开启一个定时器，如果超时还没有收到<code>ACK</code>会重发 SYN。</p>
<p>运行上面的脚本，然后使用 netstat 命令查看连接状态l</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">netstat</span> <span class="string">-atnp</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-i</span> <span class="number">8080</span>                                                                                                    </span><br><span class="line"><span class="string">tcp</span>        <span class="number">0</span>      <span class="number">1</span> <span class="number">192.168</span><span class="number">.46</span><span class="number">.26</span><span class="string">:42678</span>     <span class="number">192.0</span><span class="number">.2</span><span class="number">.1</span><span class="string">:8080</span>          <span class="string">SYN_SENT</span>    <span class="number">3897</span><span class="string">/packetdrill</span></span><br></pre></td></tr></table></figure>

<p><strong>4、SYN-RCVD</strong></p>
<p>服务端收到<code>SYN</code>报文以后会回复 <code>SYN+ACK</code>，然后等待对端 ACK 的时候进入<code>SYN-RCVD</code></p>
<p><strong>5、ESTABLISHED</strong></p>
<p><code>SYN-SENT</code>或者<code>SYN-RCVD</code>状态的连接收到对端确认<code>ACK</code>以后进入<code>ESTABLISHED</code>状态，连接建立成功。</p>
<p>把上面例子中脚本的注释取消掉，三次握手成功就会进入<code>ESTABLISHED</code>状态。</p>
<p>从图中可以看到<code>ESTABLISHED</code>状态的连接有两种可能的状态转换方式:</p>
<ul>
<li>调用 close 等系统调用主动关闭连接，这个时候会发送 FIN 包给对端，同时自己进入<code>FIN-WAIT-1</code>状态</li>
<li>收到对端的 FIN 包，执行被动关闭，收到 <code>FIN</code> 包以后会回复 <code>ACK</code>，同时自己进入<code>CLOSE-WAIT</code>状态</li>
</ul>
<p><strong>6、FIN-WAIT-1</strong></p>
<p>主动关闭的一方发送了 FIN 包，等待对端回复 ACK 时进入<code>FIN-WAIT-1</code>状态。</p>
<p><code>FIN_WAIT1</code>状态的切换如下几种情况</p>
<ul>
<li>当收到 <code>ACK</code> 以后，<code>FIN-WAIT-1</code>状态会转换到<code>FIN-WAIT-2</code>状态</li>
<li>当收到 <code>FIN</code> 以后，会回复对端 <code>ACK</code>，<code>FIN-WAIT-1</code>状态会转换到<code>CLOSING</code>状态</li>
<li>当收到 <code>FIN+ACK</code> 以后，会回复对端 <code>ACK</code>，<code>FIN-WAIT-1</code>状态会转换到<code>TIME_WAIT</code>状态，跳过了<code>FIN-WAIT-2</code>状态</li>
</ul>
<p><strong>7、FIN-WAIT-2</strong></p>
<p>处于 <code>FIN-WAIT-1</code>状态的连接收到 ACK 确认包以后进入<code>FIN-WAIT-2</code>状态，这个时候主动关闭方的 FIN 包已经被对方确认，等待被动关闭方发送 FIN 包。</p>
<p><strong>8、CLOSE-WAIT</strong></p>
<p>当有一方想关闭连接的时候，调用 close 等系统调用关闭 TCP 连接会发送 FIN 包给对端，这个被动关闭方，收到 FIN 包以后进入<code>CLOSE-WAIT</code>状态。</p>
<p>当被动关闭方有数据要发送给对端的时候，可以继续发送数据。当没有数据发送给对方时，也会调用 close 等系统调用关闭 TCP 连接，发送 FIN 包给主动关闭的一方，同时进入<code>LAST-ACK</code>状态。</p>
<p><strong>9、TIME-WAIT</strong></p>
<p><code>TIME-WAIT</code>可能是所有状态中面试问的最频繁的一种状态了。这个状态是收到了被动关闭方的 FIN 包，发送确认 ACK 给对端，开启 2MSL 定时器，定时器到期时进入 <code>CLOSED</code> 状态，连接释放。<code>TIME-WAIT</code> 会有专门的文章介绍。</p>
<p><strong>10、LAST-ACK</strong></p>
<p><code>LAST-ACK</code> 顾名思义等待最后的 ACK。是被动关闭的一方，发送 FIN 包给对端等待 ACK 确认时的状态。</p>
<p><strong>11、CLOSING</strong></p>
<p><code>CLOSING</code>状态在「同时关闭」的情况下出现。这里的同时关闭中的「同时」其实并不是时间意义上的同时，而是指的是在发送 FIN 包还未收到确认之前，收到了对端的 FIN 的情况。</p>
<h2 id="14-另辟蹊径看三次握手-——-全连接队列和半连接队列与-backlog"><a href="#14-另辟蹊径看三次握手-——-全连接队列和半连接队列与-backlog" class="headerlink" title="14 另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog"></a>14 另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog</h2><p>关于三次握手，还有很多细节之前的文章没有详细介绍，这篇文章我们以 backlog 参数来深入研究一下建连的过程。通过阅读这篇文章，你会了解到下面这些知识：</p>
<ul>
<li>backlog、半连接队列、全连接队列是什么</li>
<li>linux 内核是如何计算半连接队列、全连接队列的</li>
<li>为什么只修改系统的 somaxconn 和 tcp_max_syn_backlog 对最终的队列大小不起作用</li>
<li>如何使用 systemtap 探针获取当前系统的半连接、全连接队列信息</li>
<li>iprouter 库中的 ss 工具的原理是什么</li>
<li>如何快速模拟半连接队列溢出，全连接队列溢出</li>
</ul>
<h3 id="14-1-半连接队列、全连接队列基本概念"><a href="#14-1-半连接队列、全连接队列基本概念" class="headerlink" title="14.1 半连接队列、全连接队列基本概念"></a>14.1 半连接队列、全连接队列基本概念</h3><p>为了理解 backlog，我们需要了解 listen 和 accept 函数背后的发生了什么。backlog 参数跟 listen 函数有关，listen 函数的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>当服务端调用 listen 函数时，TCP 的状态被从 CLOSE 状态变为 LISTEN，于此同时内核创建了两个队列：</p>
<ul>
<li>半连接队列（Incomplete connection queue），又称 SYN 队列</li>
<li>全连接队列（Completed connection queue），又称 Accept 队列</li>
</ul>
<p>如下图所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/28/16b9dae5efc47de8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>接下来开始详细介绍这两个队列相关的内容。</p>
<h3 id="14-2-半连接队列（SYN-Queue）"><a href="#14-2-半连接队列（SYN-Queue）" class="headerlink" title="14.2 半连接队列（SYN Queue）"></a>14.2 半连接队列（SYN Queue）</h3><p>当客户端发起 SYN 到服务端，服务端收到以后会回 ACK 和自己的 SYN。这时服务端这边的 TCP 从 listen 状态变为 SYN_RCVD (SYN Received)，此时会将这个连接信息放入「半连接队列」，半连接队列也被称为 SYN Queue，存储的是 “inbound SYN packets”。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/23/16918ddaf0b49c7e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>服务端回复 SYN+ACK 包以后等待客户端回复 ACK，同时开启一个定时器，如果超时还未收到 ACK 会进行 SYN+ACK 的重传，重传的次数由 tcp_synack_retries 值确定。在 CentOS 上这个值等于 5。</p>
<p>一旦收到客户端的 ACK，服务端就开始<strong>尝试</strong>把它加入另外一个全连接队列（Accept Queue）。</p>
<h3 id="14-3-全连接队列（Accept-Queue）"><a href="#14-3-全连接队列（Accept-Queue）" class="headerlink" title="14.3 全连接队列（Accept Queue）"></a>14.3 全连接队列（Accept Queue）</h3><p>「全连接队列」包含了服务端所有完成了三次握手，但是还未被应用调用 accept 取走的连接队列。此时的 socket 处于 ESTABLISHED 状态。每次应用调用 accept() 函数会移除队列头的连接。如果队列为空，accept() 通常会阻塞。全连接队列也被称为 Accept 队列。</p>
<p>你可以把这个过程想象生产者、消费者模型。内核是一个负责三次握手的生产者，握手完的连接会放入一个队列。我们的应用程序是一个消费者，取走队列中的连接进行下一步的处理。这种生产者消费者的模式，在生产过快、消费过慢的情况下就会出现队列积压。</p>
<p>listen 函数的第二个参数 backlog 用来设置全连接队列大小，但不一定就会选用这一个 backlog 值，还受限于 somaxconn，等下会有更详细的内容说明全连接队列大小的计算规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog)</span><br></pre></td></tr></table></figure>

<p>如果全连接队列满，内核会舍弃掉 client 发过来的 ack（应用层会认为此时连接还未完全建立）</p>
<p><strong>我们来模拟一下全连接队列满的情况。因为只有 accept 才会移除全连接的队列，所以如果我们只 listen，不调用 accept，那么很快全连接就可以被占满。</strong></p>
<p>以下记客户端 10.211.55.20 为 A，服务端 10.211.55.10 为 B</p>
<ul>
<li>1：客户端 A 发起 SYN 到服务端 B 的 9090 端口，开始三次握手的第一步</li>
<li>2：服务器 B 马上回复了 ACK + SYN，此时 服务器 B socket处于 SYN_RCVD 状态</li>
<li>3：客户端 A 收到服务器 B 的 ACK + SYN，发送三次握手最后一步的 ACK 给服务器 B，自己此时处于 ESTABLISHED 状态，与此同时，由于服务器 B 的全连接队列满，它会丢掉这个 ACK，连接还未建立</li>
<li>4：服务端 B 因为认为没有收到 ACK，以为是自己在 2 中的 SYN + ACK 在传输过程中丢掉了，所以开始重传，期待客户端能重新回复 ACK。</li>
<li>5：客户端 A 收到 B 的 SYN + ACK 以后，确实马上回复了 ACK</li>
<li>6 ~ 13：但是这个 ACK 同样也会被服务器 B 丢弃，服务端 B 还是认为没有收到 ACK，继续重传重传的过程同样也是指数级退避的（1s、2s、4s、8s、16s），总共历时 31s 重传 5 次 <code>SYN + ACK</code> 以后，服务器 B 认为没有希望，一段时间后此条 tcp 连接就被系统回收了。</li>
</ul>
<p>SYN+ACK重传的次数是由操作系统的一个文件决定的<code>/proc/sys/net/ipv4/tcp_synack_retries</code>，可以用 cat 查看这个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_synack_retries</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>整个过程如下图所示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/23/16918ddaf0d4afa5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="14-4-全连接队列的大小"><a href="#14-4-全连接队列的大小" class="headerlink" title="14.4 全连接队列的大小"></a>14.4 全连接队列的大小</h3><p>全连接队列的大小是 listen 传入的 backlog 和 somaxconn 中的较小值。</p>
<h3 id="14-5-多大的-backlog-是合适的"><a href="#14-5-多大的-backlog-是合适的" class="headerlink" title="14.5 多大的 backlog 是合适的"></a>14.5 多大的 backlog 是合适的</h3><p>前面讲了这么多，应用程序设置多大的 backlog 是合理的呢？</p>
<p>答案是 It depends，根据不同过的业务场景，需要做对应的调整。</p>
<ul>
<li>你如果的接口处理连接的速度要求非常高，或者在做压力测试，很有必要调高这个值</li>
<li>如果业务接口本身性能不好，accept 取走已建连的速度较慢，那么把 backlog 调的再大也没有用，只会增加连接失败的可能性</li>
</ul>
<p>可以举个典型的 backlog 值供大家参考，Nginx 和 Redis 默认的 backlog 值等于 511，Linux 默认的 backlog 为 128，Java 默认的 backlog 等于 50</p>
<h3 id="14-6-tcp-abort-on-overflow-参数"><a href="#14-6-tcp-abort-on-overflow-参数" class="headerlink" title="14.6 tcp_abort_on_overflow 参数"></a>14.6 tcp_abort_on_overflow 参数</h3><p>默认情况下，全连接队列满以后，服务端会忽略客户端的 ACK，随后会重传<code>SYN+ACK</code>，也可以修改这种行为，这个值由<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>决定。</p>
<ul>
<li>tcp_abort_on_overflow 为 0 表示三次握手最后一步全连接队列满以后 server 会丢掉 client 发过来的 ACK，服务端随后会进行重传 SYN+ACK。</li>
<li>tcp_abort_on_overflow 为 1 表示全连接队列满以后服务端直接发送 RST 给客户端。</li>
</ul>
<p>但是回给客户端 RST 包会带来另外一个问题，客户端不知道服务端响应的 RST 包到底是因为「该端口没有进程监听」，还是「该端口有进程监听，只是它的队列满了」。</p>
<h3 id="14-7-小结"><a href="#14-7-小结" class="headerlink" title="14.7 小结"></a>14.7 小结</h3><p>这篇文章我们从 backlog 参数为入口来研究了半连接队列、全连接队列的关系。简单回顾一下。</p>
<ul>
<li>半连接队列：服务端收到客户端的 SYN 包，回复 SYN+ACK 但是还没有收到客户端 ACK 情况下，会将连接信息放入半连接队列。半连接队列又被称为 SYN 队列。</li>
<li>全连接队列：服务端完成了三次握手，但是还未被 accept 取走的连接队列。全连接队列又被称为 Accept 队列。</li>
<li>半连接队列的大小与用户 listen 传入的 backlog、net.core.somaxconn、net.core.somaxconn 都有关系，准确的计算规则见上面的源码分析</li>
<li>全连接队列的大小是用户 listen 传入的 backlog 与 net.core.somaxconn 的较小值</li>
</ul>
<h2 id="15-原始但德高望重的-DDoS-攻击方式-——-SYN-Flood-攻击原理"><a href="#15-原始但德高望重的-DDoS-攻击方式-——-SYN-Flood-攻击原理" class="headerlink" title="15 原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理"></a>15 原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理</h2><h3 id="15-1-SYN-flood-攻击"><a href="#15-1-SYN-flood-攻击" class="headerlink" title="15.1 SYN flood 攻击"></a>15.1 SYN flood 攻击</h3><p>SYN Flood 是一种广为人知的 DoS（拒绝服务攻击） 想象一个场景：客户端大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态，而服务器的半连接队列大小也是有限的，如果半连接队列满，也会出现无法处理正常请求的情况。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba36e681b24ff3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>使用 netstat 查看服务器的状态</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnpat | <span class="keyword">grep</span> :<span class="number">80</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:<span class="number">80</span>              <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>:*               LISTEN      -</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">10.211</span>.<span class="number">55.10</span>:<span class="number">80</span>         <span class="number">23.16</span>.<span class="number">63.3</span>:<span class="number">20</span>           SYN_RECV    -</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">10.211</span>.<span class="number">55.10</span>:<span class="number">80</span>         <span class="number">23.16</span>.<span class="number">64.3</span>:<span class="number">20</span>           SYN_RECV    -</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">10.211</span>.<span class="number">55.10</span>:<span class="number">80</span>         <span class="number">23.16</span>.<span class="number">62.3</span>:<span class="number">20</span>           SYN_RECV    -</span><br></pre></td></tr></table></figure>

<p><strong>服务端的 SYN_RECV 的数量偶尔涨起来又降下去，因为对端回了 RST 包，这条连接在收到 RST 以后就被从半连接队列清除了。如果攻击者控制了大量的机器，同时发起 SYN，依然会对服务器造成不小的影响。</strong></p>
<p>而且 <code>SYN+ACK</code> 去到的不知道是哪里的主机，是否回复 RST 完全取决于它自己，万一它不直接忽略掉 SYN，不回复 RST，问题就更严重了。服务端以为自己的 SYN+ACK 丢失了，会进行重传。</p>
<p>我们来模拟一下这种场景。因为没有办法在去 <code>SYN+ACK</code> 包去到的主机的配置，可以在服务器用 iptables 墙掉主机发过来的 RST 包，模拟主机没有回复 RST 包的情况。</p>
<p>这个时候再次使用 netstat 查看，满屏的 SYN_RECV 出现了</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba36e691c556be~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>通过服务端抓包的文件也可以看到，服务端因为 SYN+ACK 丢了，然后进行重传。重传的次数由<code>/proc/sys/net/ipv4/tcp_synack_retries</code>文件决定，在我的 Centos 上这个默认值为 5。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba36e68300ff13~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>重传 5 次 SYN+ACK 包，重传的时间依然是指数级退避（1s、2s、4s、8s、16s），发送完最后一次 SYN+ACK 包以后，等待 32s，服务端才会丢弃掉这个连接，把处于SYN_RECV 状态的 socket 关闭。</p>
<p><strong>在这种情况下，一次恶意的 SYN 包，会占用一个服务端连接 63s（1+2+4+8+16+32），如果这个时候有大量的恶意 SYN 包过来连接服务器，很快半连接队列就被占满，不能接收正常的用户请求。</strong></p>
<h3 id="15-2-如何应对-SYN-Flood-攻击"><a href="#15-2-如何应对-SYN-Flood-攻击" class="headerlink" title="15.2 如何应对 SYN Flood 攻击"></a>15.2 如何应对 SYN Flood 攻击</h3><p>常见的有下面这几种方法</p>
<h4 id="增加-SYN-连接数：tcp-max-syn-backlog"><a href="#增加-SYN-连接数：tcp-max-syn-backlog" class="headerlink" title="增加 SYN 连接数：tcp_max_syn_backlog"></a>增加 SYN 连接数：tcp_max_syn_backlog</h4><p>调大<code>net.ipv4.tcp_max_syn_backlog</code>的值，不过这只是一个心理安慰，真有攻击的时候，这个再大也不够用。</p>
<h4 id="减少SYN-ACK重试次数：tcp-synack-retries"><a href="#减少SYN-ACK重试次数：tcp-synack-retries" class="headerlink" title="减少SYN+ACK重试次数：tcp_synack_retries"></a>减少<code>SYN+ACK</code>重试次数：tcp_synack_retries</h4><p>重试次数由 <code>/proc/sys/net/ipv4/tcp_synack_retries</code>控制，默认情况下是 5 次，当收到<code>SYN+ACK</code>故意不回 ACK 或者回复的很慢的时候，调小这个值很有必要。</p>
<p><strong>还有一个比较复杂的 tcp_syncookies 机制，下面来详细介绍一下。</strong></p>
<h3 id="15-3-SYN-Cookie-机制"><a href="#15-3-SYN-Cookie-机制" class="headerlink" title="15.3 SYN Cookie 机制"></a>15.3 SYN Cookie 机制</h3><p>SYN Cookie 机制其实原理比较简单，就是在三次握手的最后阶段才分配连接资源，如下图所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/29/16ba36e691d04901~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><strong>SYN Cookie 的原理是基于「无状态」的机制，服务端收到 SYN 包以后不马上分配为 <code>Inbound SYN</code>分配内存资源，而是根据这个 SYN 包计算出一个 Cookie 值，作为握手第二步的序列号回复 SYN+ACK，等对方回应 ACK 包时校验回复的 ACK 值是否合法，如果合法才三次握手成功，分配连接资源。</strong></p>
<p>SYN Cookie 看起来比较完美，但是也有不少的问题。</p>
<p>第一，这里的 MSS 值只能是少数的几种，由数组 msstab 值决定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __u16 <span class="type">const</span> msstab[] = &#123;</span><br><span class="line">	<span class="number">536</span>,</span><br><span class="line">	<span class="number">1300</span>,</span><br><span class="line">	<span class="number">1440</span>,	<span class="comment">/* 1440, 1452: PPPoE */</span></span><br><span class="line">	<span class="number">1460</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二，<strong>因为 syn-cookie 是一个无状态的机制，服务端不保存状态，不能使用其它所有 TCP 选项，比如 WScale，SACK 这些。因此要想变相支持这些选项就得想想其它的偏门，如果启用了 Timestamp 选项，可以把这些值放在 Timestamp 选项值里面。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">26</span> bits  <span class="operator">|</span> <span class="number">1</span> bit <span class="operator">|</span> <span class="number">1</span> bit <span class="operator">|</span> <span class="number">4</span> bits <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="type">Timestamp</span> <span class="operator">|</span>  ECN  <span class="operator">|</span> SACK  <span class="operator">|</span> WScale <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-------+-------+--------+</span></span><br></pre></td></tr></table></figure>

<p>不在上面这个四个字段中的扩展选项将无法支持了，如果没有启用 Timestamp 选项，那就彻底凉凉了。</p>
<h2 id="16-嫌三次握手太慢-——-来快速打开吧"><a href="#16-嫌三次握手太慢-——-来快速打开吧" class="headerlink" title="16 嫌三次握手太慢 —— 来快速打开吧"></a>16 嫌三次握手太慢 —— 来快速打开吧</h2><p>前面几篇文章讲了三次握手的过程，可能你会有觉得好麻烦呀，要发数据先得有三次包交互建连。三次握手带来的延迟使得创建一个新 TCP 连接代价非常大，所有有了各种连接重用的技术。</p>
<p>但是连接并不是想重用就重用的，<strong>在不重用连接的情况下，如何减少新建连接代理的性能损失呢？</strong></p>
<p><strong>于是人们提出了 TCP 快速打开（TCP Fast Open，TFO），尽可能降低握手对网络延迟的影响。今天我们就讲讲这其中的原理。</strong></p>
<h3 id="16-1-TFO-简介"><a href="#16-1-TFO-简介" class="headerlink" title="16.1 TFO 简介"></a>16.1 TFO 简介</h3><p>TFO 是在原来 TCP 协议上的扩展协议，它的主要原理就在发送第一个 SYN 包的时候就开始传数据了，不过它要求当前客户端之前已经完成过「正常」的三次握手。<strong>快速打开分两个阶段：请求 Fast Open Cookie 和 真正开始 TCP Fast Open。</strong></p>
<p>请求 Fast Open Cookie 的过程如下：</p>
<ul>
<li>客户端发送一个 SYN 包，头部包含 Fast Open 选项，且该选项的Cookie 为空，这表明客户端请求 Fast Open Cookie</li>
<li>服务端收取 SYN 包以后，生成一个 cookie 值（一串字符串）</li>
<li>服务端发送 SYN + ACK 包，在 Options 的 Fast Open 选项中设置 cookie 的值</li>
<li>客户端缓存服务端的 IP 和收到的 cookie 值</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/3/169e2dc0888e6b83~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>第一次过后，客户端就有了缓存在本地的 cookie 值，后面的握手和数据传输过程如下：</p>
<ul>
<li>客户端发送 SYN 数据包，里面包含数据和之前缓存在本地的 Fast Open Cookie。（注意我们此前介绍的所有 SYN 包都不能包含数据）</li>
<li>服务端检验收到的 TFO Cookie 和传输的数据是否合法。如果合法就会返回 SYN + ACK 包进行确认并将数据包传递给应用层，如果不合法就会丢弃数据包，走正常三次握手流程（只会确认 SYN）</li>
<li>服务端程序收到数据以后可以握手完成之前发送响应数据给客户端了</li>
<li>客户端发送 ACK 包，确认第二步的 SYN 包和数据（如果有的话）</li>
<li>后面的过程就跟非 TFO 连接过程一样了</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/3/169e2dc0821ff4f9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="16-2-TCP-Fast-Open-的优势"><a href="#16-2-TCP-Fast-Open-的优势" class="headerlink" title="16.2 TCP Fast Open 的优势"></a>16.2 TCP Fast Open 的优势</h3><p>一个最显著的优点是可以利用握手去除一个往返 RTT，如下图所示 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/3/169e2dc0c15f46e5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 在开启 TCP Fast Open以后，从第二次请求开始，就可以在一个 RTT 时间拿到响应的数据。</p>
<p>还有一些其它的优点，比如可以防止 SYN-Flood 攻击之类的。</p>
<h3 id="16-3-小结"><a href="#16-3-小结" class="headerlink" title="16.3 小结"></a>16.3 小结</h3><p>这篇文章主要用 curl 命令演示了 TCP 快速打开的详细过程和原理</p>
<ol>
<li><strong>客户端发送一个 SYN 包，头部包含 Fast Open 选项，且该选项的 Cookie 长度为 0</strong></li>
<li><strong>服务端根据客户端 IP 生成 cookie，放在 SYN+ACK 包中一同发回客户端</strong></li>
<li><strong>客户端收到 Cookie 以后缓存在自己的本地内存</strong></li>
<li><strong>客户端再次访问服务端时，在 SYN 包携带数据，并在头部包含 上次缓存在本地的 TCP cookie</strong></li>
<li><strong>如果服务端校验 Cookie 合法，则在客户端回复 ACK 前就可以直接发送数据。如果 Cookie 不合法则按照正常三次握手进行。</strong></li>
</ol>
<p>可以看到历代大牛在降低网络延迟方面的鬼斧神工般的努力，现在主流操作系统和浏览器都支持这个选项了。</p>
<p><em><strong><u>代码详见PPT</u></strong></em></p>
<h2 id="17-Address-already-in-use-——-聊聊-Socket-选项之-SO-REUSEADDR"><a href="#17-Address-already-in-use-——-聊聊-Socket-选项之-SO-REUSEADDR" class="headerlink" title="17 Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR"></a>17 Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR</h2><p>前面介绍到四次挥手的时候有讲到，<strong>主动断开</strong>连接的那一端需要等待 2 个 MSL 才能最终释放这个连接。一般而言，主动断开连接的都是客户端，如果是服务端程序重启或者出现 bug 崩溃，这时服务端会主动断开连接，如下图所示</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/25/169230452f26de90~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>因为要等待 2 个 MSL 才能最终释放连接，所以如果这个时候程序马上启动，就会出现<code>Address already in use</code>错误。要过 1 分钟以后才可以启动成功。<strong>如果你写了一个 web 服务器，崩溃以后被脚本自动拉起失败，需要等一分钟才正常，运维可能要骂娘了。</strong></p>
<p>下面来写一段简单的代码演示这个场景是如何产生的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReuseAddress</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">        <span class="comment">// setReuseAddress 必须在 bind 函数调用之前执行</span></span><br><span class="line">        serverSocket.setReuseAddress(<span class="literal">false</span>);</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;reuse address: &quot;</span> + serverSocket.getReuseAddress());</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;incoming socket..&quot;</span>);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            out.write(<span class="string">&quot;Hello\n&quot;</span>.getBytes());</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的功能是启动一个 TCP 服务器，客户端连上来就返回了一个 “Hello\n” 回去。</p>
<p>使用 javac 编译 class 文件<code>javac ReuseAddress.java;</code>，然后用 java 命令运行<code>java -cp . ReuseAddress</code>。使用 nc 命令连接 8080 端口<code>nc localhost 8080</code>，应该会马上收到服务端返回的”Hello\n”字符串。现在 kill 这个进程，马上重启这个程序就可以看到程序启动失败，报 socket bind 失败，堆栈如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.net.BindException: 地址已在使用 (Bind failed)</span><br><span class="line">	at java.net.PlainSocketImpl.socketBind(Native Method)</span><br><span class="line">	at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:<span class="number">387</span>)</span><br><span class="line">	at java.net.ServerSocket.bind(ServerSocket.java:<span class="number">375</span>)</span><br><span class="line">	at java.net.ServerSocket.bind(ServerSocket.java:<span class="number">329</span>)</span><br><span class="line">	at ReuseAddress.main(ReuseAddress.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p><strong>将代码修改为<code>serverSocket.setReuseAddress(true);</code>，再次重复上面的测试过程，再也不会出现上述异常了。</strong></p>
<h3 id="17-1-为什么需要-SO-REUSEADDR-参数"><a href="#17-1-为什么需要-SO-REUSEADDR-参数" class="headerlink" title="17.1 为什么需要 SO_REUSEADDR 参数"></a>17.1 为什么需要 SO_REUSEADDR 参数</h3><p>服务端主动断开连接以后，需要等 2 个 MSL 以后才最终释放这个连接，重启以后要绑定同一个端口，默认情况下，操作系统的实现都会阻止新的监听套接字绑定到这个端口上。</p>
<p>我们都知道 TCP 连接由四元组唯一确定。形式如下</p>
<p>{local-ip-address:local-port , foreign-ip-address:foreign-port}</p>
<p>一个典型的例子如下图</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/25/169230452a3ad54a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>TCP 要求这样的四元组必须是唯一的，但大多数操作系统的实现要求更加严格，只要还有连接在使用这个本地端口，则本地端口不能被重用（bind 调用失败）</p>
<p><strong>启用 SO_REUSEADDR 套接字选项可以解除这个限制，默认情况下这个值都为 0，表示关闭。在 Java 中，reuseAddress 不同的 JVM 有不同的实现，在我本机上，这个值默认为 1 允许端口重用。但是为了保险起见，写 TCP、HTTP 服务一定要主动设置这个参数为 1。</strong></p>
<h3 id="17-2-是不是只有处于-TIME-WAIT-才允许端口复用？"><a href="#17-2-是不是只有处于-TIME-WAIT-才允许端口复用？" class="headerlink" title="17.2 是不是只有处于 TIME_WAIT 才允许端口复用？"></a>17.2 是不是只有处于 TIME_WAIT 才允许端口复用？</h3><p>假设因为网络的原因，客户端没有回发 FIN 包，导致服务器端处于 FIN_WAIT2 状态，而非 TIME_WAIT 状态，那设置 SO_REUSEADDR 还会生效吗？</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/25/169252c596fbaac0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>来做一个实验，现在有两台机器c1（充当客户端），c2（充当服务器）。在客户端 c1 利用防火墙拦截掉所有发出的 FIN 包：<code>sudo iptables --append OUTPUT --match tcp --protocol tcp --dport 8080 --tcp-flags FIN FIN --jump DROP</code>。 在c1 上使用<code>nc c2 8080</code>发起 tcp 连接，随后杀掉 c2 的进程， 因为服务端收不到客户端发过来的 FIN 包，也即四次挥手中的第 3 步没能成功，服务端此时将处于 FIN_WAIT2 状态。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ya@c2 ~$ sudo netstat -lnpa  | <span class="keyword">grep</span> <span class="number">8080</span></span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> <span class="number">10.211</span>.<span class="number">55.10</span>:<span class="number">8080</span>       <span class="number">10.211</span>.<span class="number">55.5</span>:<span class="number">39664</span>       FIN_WAIT2   -</span><br></pre></td></tr></table></figure>

<p>将 SO_REUSEADDR 设置为 1，重复上面的测试过程，将发现不会出现异常。将 SO_REUSEADDR 设置为 0，则会出现 Address already in use 异常。</p>
<p><strong>因此，不一定是要处于 TIME_WAIT 才允许端口复用的，只是大都是情况下，主动关闭连接的服务端都会处于 TIME_WAIT。如果不把 SO_REUSEADDR 设置为 1，服务器将等待 2 个 MSL 才可以重新绑定原端口</strong></p>
<h3 id="17-3-为什么通常不会在客户端上出现"><a href="#17-3-为什么通常不会在客户端上出现" class="headerlink" title="17.3 为什么通常不会在客户端上出现"></a>17.3 为什么通常不会在客户端上出现</h3><p>通常情况下都是客户端主动关闭连接，那客户端那边为什么不会有问题呢？</p>
<p><strong>因为客户端都是用的临时端口，这些临时端口与处于 TIME_WAIT 状态的端口恰好相同的可能性不大，就算相同换一个新的临时端口就好了。</strong></p>
<h2 id="18-一台主机上两个进程可以同时监听同一个端口吗"><a href="#18-一台主机上两个进程可以同时监听同一个端口吗" class="headerlink" title="18 一台主机上两个进程可以同时监听同一个端口吗"></a>18 一台主机上两个进程可以同时监听同一个端口吗</h2><p>在日常的开发过程中，经常会遇到端口占用冲突的问题。那是不是不同的进程不能同时监听同一个端口呢？这个小节就来介绍 SO_REUSEPORT 选项相关的内容。</p>
<p>通过阅读这个小节，你会学到如下知识。</p>
<ul>
<li>SO_REUSEPORT 选项是什么</li>
<li>什么是惊群效应</li>
<li>SO_REUSEPORT 选项安全性相关的问题</li>
<li>Linux 内核实现端口选择过程的源码分析</li>
</ul>
<h3 id="18-1-SO-REUSEPORT-是什么"><a href="#18-1-SO-REUSEPORT-是什么" class="headerlink" title="18.1 SO_REUSEPORT 是什么"></a>18.1 SO_REUSEPORT 是什么</h3><p>默认情况下，一个 IP、端口组合只能被一个套接字绑定，Linux 内核从 3.9 版本开始引入一个新的 socket 选项 SO_REUSEPORT，又称为 port sharding，允许多个套接字监听同一个IP 和端口组合。</p>
<p><strong>为了充分发挥多核 CPU 的性能，多进程的处理网络请求主要有下面两种方式</strong></p>
<ul>
<li><strong>主进程 + 多个 worker 子进程监听相同的端口</strong></li>
<li><strong>多进程 + REUSEPORT</strong></li>
</ul>
<p>第一种方最常用的一种模式，Nginx 默认就采用这种方式。主进程执行 bind()、listen() 初始化套接字，然后 fork 新的子进程。在这些子进程中，通过 accept/epoll_wait 同一个套接字来进行请求处理，示意图如下所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53ee520a443~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="reuseport_nginx"></p>
<p>这种方式看起来很完美，但是会带来著名的“惊群”问题（thundering herd）。</p>
<h3 id="18-2-惊群问题（thundering-herd）"><a href="#18-2-惊群问题（thundering-herd）" class="headerlink" title="18.2 惊群问题（thundering herd）"></a>18.2 惊群问题（thundering herd）</h3><p>在开始介绍惊群之前，我们下来看看一个现实世界中的惊群问题。假如你养了五条狗，一开始这五条狗都在睡觉，你过去扔了一块骨头，这五条狗都从睡梦中醒来，一起跑过来争抢这块骨头，最终只有第三条狗抢到了这块骨头，剩下的四条狗只好无奈的继续睡觉。如下图所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53ee58979c9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="惊群"></p>
<p>从上面的例子可以看到，明明只有一块骨头只够一条小狗吃，五只小狗却一起从睡眠中醒来争抢，对于没有抢到小狗来说，浪费了很多精力。</p>
<p>计算机中的惊群问题指的是：多进程/多线程同时监听同一个套接字，当有网络事件发生时，所有等待的进程/线程同时被唤醒，但是只有其中一个进程/线程可以处理该网络事件，其它的进程/线程获取失败重新进入休眠。</p>
<p><strong>惊群问题带来的是 CPU 资源的浪费和锁竞争的开销。根据使用方式的不同，Linux 上的网络惊群问题分为 accept 惊群和 epoll 惊群两种。</strong></p>
<h3 id="18-3-epoll-惊群"><a href="#18-3-epoll-惊群" class="headerlink" title="18.3 epoll 惊群"></a>18.3 epoll 惊群</h3><p>epoll 典型的工作模式是父进程执行 bind、listen 以后 fork 出子进程，使用 epoll_wait 等待事件发生，模式如下图所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53ee57fc0cb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="epoll 工作模式"></p>
<p>为了表示打开文件，linux 内核维护了三种数据结构，分别是：</p>
<ul>
<li>内核为每个进程维护了一个其打开文件的「描述符表」（file descriptor table），我们熟知的 fd 为 0 的 stdin 就是属于文件描述符表。</li>
<li>内核为所有打开文件维护了一个系统级的「打开文件表」（open file table），这个打开文件表存储了当前文件的偏移量，状态信息和对 inode 的指针等信息，父子进程的 fd 可以指向同一个打开文件表项。</li>
<li>最后一个是文件系统的 inode 表（i-node table）</li>
</ul>
<p>经过 for 循环的 fork，会生成 4 个子进程，这 4 个子进程会继承父进程的 fd。在这种情况下，对应的进程文件描述符表、打开文件表和 inode 表的关系如下图所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53ee593eeca~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="epoll_fd"></p>
<p>子进程的 epoll_wait 等待同一个底层的 open file table 项，当有事件发送时，会通知到所有的子进程。</p>
<p>编译运行上面的，使用 <code>nc -i 1 localhost 9090</code> 发起网络请求，输出结果如下所示。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">from</span> epoll_wait, pid <span class="keyword">is</span> <span class="number">25410</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">from</span> epoll_wait, pid <span class="keyword">is</span> <span class="number">25411</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">from</span> epoll_wait, pid <span class="keyword">is</span> <span class="number">25409</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">from</span> epoll_wait, pid <span class="keyword">is</span> <span class="number">25412</span></span><br><span class="line">accept success, pid <span class="keyword">is</span> <span class="number">25410</span></span><br><span class="line">accept failed, pid <span class="keyword">is</span> <span class="number">25411</span></span><br><span class="line">accept failed, pid <span class="keyword">is</span> <span class="number">25409</span></span><br><span class="line">accept failed, pid <span class="keyword">is</span> <span class="number">25412</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到当有新的网络事件发生时，阻塞在 epoll_wait 的多个进程同时被唤醒。在这种情况下，epoll 的惊群还是存在，有不少的措施可以解决 epoll 的惊群。Nginx 为了处理惊群问题，在应用层增加了 accept_mutex 锁，这里不再展开，有兴趣的读者可以再深入学习一下这部分的知识。</strong></p>
<p><strong>为了解决惊群问题，比较省力省心的方式是使用 SO_REUSEPORT 选项，接下来开始介绍这部分的内容。</strong></p>
<h3 id="18-4-SO-REUSEPORT-的应用"><a href="#18-4-SO-REUSEPORT-的应用" class="headerlink" title="18.4 SO_REUSEPORT 的应用"></a>18.4 SO_REUSEPORT 的应用</h3><p>SO_REUSEPORT 带来了两个明显的好处：</p>
<ul>
<li>实现了内核级的负载均衡</li>
<li>支持滚动升级（Rolling updates）</li>
</ul>
<p>内核级的负载均衡在前面的 Nginx 的例子中已经介绍过了，这里不再赘述。使用 SO_REUSEPORT 做滚动升级的过程如下图所示。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/31/16ffa53f205214ae~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="rolling-update"></p>
<p>步骤如下所示。</p>
<ol>
<li>新启动一个新版本 v2 ，监听同一个端口，与 v1 旧版本一起处理请求。</li>
<li>发送信号给 v1 版本的进程，让它不再接受新的请求</li>
<li>等待一段时间，等 v1 版本的用户请求都已经处理完毕时，v1 版本的进程退出，留下 v2 版本继续服务</li>
</ol>
<h2 id="19-优雅关闭连接-——-Socket-选项之-SO-LINGER"><a href="#19-优雅关闭连接-——-Socket-选项之-SO-LINGER" class="headerlink" title="19 优雅关闭连接 —— Socket 选项之 SO_LINGER"></a>19 优雅关闭连接 —— Socket 选项之 SO_LINGER</h2><p>这篇文章我们来讲一个新的参数 SO_LINGER，以一个小测验来开始今天的文章。 请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line"><span class="type">InetSocketAddress</span> <span class="variable">serverSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;10.0.0.3&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">socket.connect(serverSocketAddress);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] msg = getMessageBytes(); </span><br><span class="line">socket.getOutputStream().write(msg);</span><br><span class="line"></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<p><strong>会发现如下哪个选项的事情</strong></p>
<ol>
<li><strong>服务器收到 msg 所有内容</strong></li>
<li><strong>服务器会收到 msg 部分内容</strong></li>
<li><strong>服务器会抛出异常</strong></li>
</ol>
<p>简化为图如下： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a02b90d9589384~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>当我们调用 write 函数向内核写入一段数据时，内核会把这段数据放入一个缓冲区 buffer，如下图所示</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a02b90d978ff34~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="19-1-关闭连接的两种方式"><a href="#19-1-关闭连接的两种方式" class="headerlink" title="19.1 关闭连接的两种方式"></a>19.1 关闭连接的两种方式</h3><p>前面有介绍过有两种方式可以关闭 TCP 连接</p>
<ul>
<li>FIN：优雅关闭，发送 FIN 包表示自己这端所有的数据都已经发送出去了，后面不会再发送数据</li>
<li>RST：强制连接重置关闭，无法做出什么保证</li>
</ul>
<p>当调用 socket.close() 的时候会发生什么呢？</p>
<p>正常情况下</p>
<ul>
<li>操作系统等所有的数据发送完才会关闭连接</li>
<li>因为是主动关闭，所以连接将处于 TIME_WAIT 两个 MSL</li>
</ul>
<p>前面说了正常情况，那一定有不正常的情况下，<strong>如果我们不想等那么久才彻底关闭这个连接怎么办，这就是我们这篇文章介绍的主角 SO_LINGER</strong></p>
<h3 id="19-2-SO-LINGER"><a href="#19-2-SO-LINGER" class="headerlink" title="19.2 SO_LINGER"></a>19.2 SO_LINGER</h3><p>Linux 的套接字选项SO_LINGER 用来改变socket 执行 close() 函数时的默认行为。</p>
<p>linger 的英文释义有逗留、徘徊、继续存留、缓慢消失的意思。这个释义与这个参数真正的含义很接近。</p>
<p><strong>SO_LINGER 启用时，操作系统开启一个定时器，在定时器期间内发送数据，定时时间到直接 RST 连接。</strong></p>
<p>SO_LINGER 参数是一个 linger 结构体，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> l_onoff;    <span class="comment">/* linger active */</span></span><br><span class="line">    <span class="type">int</span> l_linger;   <span class="comment">/* how many seconds to linger for */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="19-3-小结"><a href="#19-3-小结" class="headerlink" title="19.3 小结"></a>19.3 小结</h3><p>这篇文章主要介绍了 SO_LINGER 套接字选项对关闭套接字的影响。默认行为下是调用 close 立即返回，但是如果有数据残留在套接字发送缓冲区中，系统将试着把这些数据发送给对端，SO_LINGER 可以改变这个默认设置，具体的规则见下面的思维导图。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a02b91ae14ef21~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h2 id="20-一个神奇的状态-——-TIME-WAIT"><a href="#20-一个神奇的状态-——-TIME-WAIT" class="headerlink" title="20 一个神奇的状态 —— TIME_WAIT"></a>20 一个神奇的状态 —— TIME_WAIT</h2><p>TIME_WAIT 是 TCP 所有状态中最不好理解的一种状态。首先，我们需要明确，<strong>只有主动断开的那一方才会进入 TIME_WAIT 状态</strong>，且会在那个状态持续 2 个 MSL（Max Segment Lifetime）。</p>
<p>为了讲清楚 TIME_WAIT，需要先介绍一下 MSL 的概念。</p>
<h3 id="20-1-MSL：Max-Segment-Lifetime"><a href="#20-1-MSL：Max-Segment-Lifetime" class="headerlink" title="20.1 MSL：Max Segment Lifetime"></a>20.1 MSL：Max Segment Lifetime</h3><p>MSL（报文最大生存时间）是 TCP 报文在网络中的最大生存时间。这个值与 IP 报文头的 TTL 字段有密切的关系。</p>
<p>IP 报文头中有一个 8 位的存活时间字段（Time to live, TTL）如下图。 这个存活时间存储的不是具体的时间，而是一个 IP 报文最大可经过的路由数，每经过一个路由器，TTL 减 1，当 TTL 减到 0 时这个 IP 报文会被丢弃。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4b9038f7aa~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>TTL 经过路由器不断减小的过程如下图所示，假设初始的 TTL 为 12，经过下一个路由器 R1 以后 TTL 变为 11，后面每经过一个路由器以后 TTL 减 1</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4b904314f8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>从上面可以看到 TTL 说的是「跳数」限制而不是「时间」限制，尽管如此我们依然假设<strong>最大跳数的报文在网络中存活的时间不可能超过 MSL 秒</strong>。Linux 的套接字实现假设 MSL 为 30 秒，因此在 Linux 机器上 TIME_WAIT 状态将持续 60秒。</p>
<h3 id="20-2-构造一个-TIME-WAIT"><a href="#20-2-构造一个-TIME-WAIT" class="headerlink" title="20.2 构造一个 TIME_WAIT"></a>20.2 构造一个 TIME_WAIT</h3><p>要构造一个 TIME_WAIT 非常简单，只需要建立一个 TCP 连接，然后断开某一方连接，主动断开的那一方就会进入 TIME_WAIT 状态，我们用 Linux 上开箱即用的 nc 命令来构造一个。过程如下图： <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4b90306b56~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>在机器 c2 上用<code>nc -l 8888</code>启动一个 TCP 服务器</li>
<li>在机器 c1 上用 <code>nc c2 8888</code> 创建一条 TCP 连接</li>
<li>在机器 c1 上用 <code>Ctrl+C</code> 停止 nc 命令，随后在用<code>netstat -atnp | grep 8888</code>查看连接状态。</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -atnp | <span class="keyword">grep</span> <span class="number">8888</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">10.211</span>.<span class="number">55.5</span>:<span class="number">60494</span>       <span class="number">10.211</span>.<span class="number">55.10</span>:<span class="number">8888</span>       TIME_WAIT   -</span><br></pre></td></tr></table></figure>

<h3 id="20-3-TIME-WAIT-存在的原因是什么"><a href="#20-3-TIME-WAIT-存在的原因是什么" class="headerlink" title="20.3 TIME_WAIT 存在的原因是什么"></a>20.3 TIME_WAIT 存在的原因是什么</h3><p>（1）<strong>第一个原因</strong>是：数据报文可能在发送途中延迟但最终会到达，因此要等老的“迷路”的重复报文段在网络中过期失效，这样可以避免用<strong>相同</strong>源端口和目标端口创建新连接时收到旧连接姗姗来迟的数据包，造成数据错乱。</p>
<p>比如下面的例子 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/15/16dce163cb0bd1d8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>假设客户端 10.211.55.2 的 61594 端口与服务端 10.211.55.10 的 8080 端口一开始建立了一个 TCP 连接。</p>
<p>假如客户端发送完 FIN 包以后不等待直接进入 CLOSED 状态，老连接 SEQ=3 的包因为网络的延迟。过了一段时间<strong>相同</strong>的 IP 和端口号又新建了另一条连接，这样 TCP 连接的四元组就完全一样了。恰好 SEQ 因为回绕等原因也正好相同，那么 SEQ=3 的包就无法知道到底是旧连接的包还是新连接的包了，造成新连接数据的混乱。</p>
<p>TIME_WAIT 等待时间是 2 个 MSL，已经足够让一个方向上的包最多存活 MSL 秒就被丢弃，保证了在创建新的 TCP 连接以后，老连接姗姗来迟的包已经在网络中被丢弃消逝，不会干扰新的连接。</p>
<p>（2）<strong>第二个原因</strong>是确保可靠实现 TCP 全双工终止连接。关闭连接的四次挥手中，最终的 ACK 由主动关闭方发出，如果这个 ACK 丢失，对端（被动关闭方）将重发 FIN，如果主动关闭方不维持 TIME_WAIT 直接进入 CLOSED 状态，则无法重传 ACK，被动关闭方因此不能及时可靠释放。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4bdb2a32f6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="20-4-为什么时间是两个-MSL"><a href="#20-4-为什么时间是两个-MSL" class="headerlink" title="20.4 为什么时间是两个 MSL"></a>20.4 为什么时间是两个 MSL</h3><ul>
<li><strong>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端</strong></li>
<li><strong>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</strong></li>
</ul>
<p><strong>2MS = 去向 ACK 消息最大存活时间（MSL) + 来向 FIN 消息的最大存活时间（MSL）</strong></p>
<h3 id="20-5-TIME-WAIT-的问题"><a href="#20-5-TIME-WAIT-的问题" class="headerlink" title="20.5 TIME_WAIT 的问题"></a>20.5 TIME_WAIT 的问题</h3><p>在一个非常繁忙的服务器上，如果有大量 TIME_WAIT 状态的连接会怎么样呢？</p>
<ul>
<li>连接表无法复用</li>
<li>socket 结构体内存占用</li>
</ul>
<p><strong>连接表无法复用</strong> <strong>因为处于 TIME_WAIT 的连接会存活 2MSL（60s），意味着相同的TCP 连接四元组（源端口、源 ip、目标端口、目标 ip）在一分钟之内都没有办法复用，通俗一点来讲就是“占着茅坑不拉屎”。</strong></p>
<p>假设主动断开的一方是客户端，对于 web 服务器而言，目标地址、目标端口都是固定值（比如本机 ip + 80 端口），客户端的 IP 也是固定的，那么能变化的就只有端口了，在一台 Linux 机器上，端口最多是 65535 个（ 2 个字节）。<strong>如果客户端与服务器通信全部使用短连接，不停的创建连接，接着关闭连接，客户端机器会造成大量的 TCP 连接进入 TIME_WAIT 状态。</strong></p>
<p>可以来写一个简单的 shell 脚本来测试一下，使用 nc 命令连接 redis 发送 ping 命令以后断开连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10000&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> ping | nc localhost 6379</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>查看一下处于 TIME_WAIT 状态的连接的个数，短短的几秒钟内，TIME_WAIT 状态的连接已经有了 8000 多个。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnpa | <span class="keyword">grep</span> -i <span class="number">6379</span> | <span class="keyword">grep</span>  TIME_WAIT| wc -l</span><br><span class="line"><span class="number">8192</span></span><br></pre></td></tr></table></figure>

<p>如果在 60s 内有超过 65535 次 redis 短连接操作，就会出现端口不够用的情况，这也是使用连接池的一个重要原因。</p>
<h3 id="20-6-应对-TIME-WAIT-的各种操作"><a href="#20-6-应对-TIME-WAIT-的各种操作" class="headerlink" title="20.6 应对 TIME_WAIT 的各种操作"></a>20.6 应对 TIME_WAIT 的各种操作</h3><p>针对 TIME_WAIT 持续时间过长的问题，Linux 新增了几个相关的选项，net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_tw_recycle。下面我们来说明一下这两个参数的用意。 这两个参数都依赖于 TCP 头部的扩展选项：timestamp</p>
<h3 id="20-7-tcp-tw-reuse-选项"><a href="#20-7-tcp-tw-reuse-选项" class="headerlink" title="20.7 tcp_tw_reuse 选项"></a>20.7 tcp_tw_reuse 选项</h3><p>缓解紧张的端口资源，一个可行的方法是重用“浪费”的处于 TIME_WAIT 状态的连接，当开启 net.ipv4.tcp_tw_reuse 选项时，处于 TIME_WAIT 状态的连接可以被重用。下面把主动关闭方记为 A， 被动关闭方记为 B，它的原理是：</p>
<ul>
<li>如果主动关闭方 A 收到的包时间戳比当前存储的时间戳小，说明是一个迷路的旧连接的包，直接丢弃掉</li>
<li>如果因为 ACK 包丢失导致被动关闭方还处于<code>LAST-ACK</code>状态，并且会持续重传 FIN+ACK。这时 A 发送SYN 包想三次握手建立连接，此时 A 处于<code>SYN-SENT</code>阶段。当收到 B 的 FIN 包时会回以一个 RST 包给 B，B 这端的连接会进入 CLOSED 状态，A 因为没有收到 SYN 包的 ACK，会重传 SYN，后面就一切顺利了。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c6fa323bd~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="20-8-tcp-tw-recyle-选项"><a href="#20-8-tcp-tw-recyle-选项" class="headerlink" title="20.8 tcp_tw_recyle 选项"></a>20.8 tcp_tw_recyle 选项</h3><p>tcp_tw_recyle 是一个比 tcp_tw_reuse 更激进的方案， 系统会缓存每台主机（即 IP）连接过来的最新的时间戳。对于新来的连接，如果发现 SYN 包中带的时间戳与之前记录的来自同一主机的同一连接的分组所携带的时间戳相比更旧，则直接丢弃。如果更新则接受复用 TIME-WAIT 连接。</p>
<p>这种机制在客户端与服务端一对一的情况下没有问题，如果经过了 NAT 或者负载均衡，问题就很严重了。</p>
<p>什么是 NAT呢？ <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/14/16b54c4c703303df~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>NAT（Network Address Translator）的出现是为了缓解 IP 地址耗尽的临时方案，IPv4 的地址是 32 位，全部利用最 多只能提 42.9 亿个地址，去掉保留地址、组播地址等剩下的只有 30 多亿，互联网主机数量呈指数级的增长，如果给每个设备都分配一个唯一的 IP 地址，那根本不够。于是 1994 年推出的 NAT 规范，NAT 设备负责维护局域网私有 IP 地址和端口到外网 IP 和端口的映射规则。</p>
<p>它有两个明显的优点</p>
<ul>
<li>出口 IP 共享：通过一个公网地址可以让许多机器连上网络，解决 IP 地址不够用的问题</li>
<li>安全隐私防护：实际的机器可以隐藏自己真实的 IP 地址 当然也有明显的弊端：NAT 会对包进行修改，有些协议无法通过 NAT。</li>
</ul>
<p>当 tcp_tw_recycle 遇上 NAT 时，因为客户端出口 IP 都一样，会导致服务端看起来都在跟同一个 host 打交道。不同客户端携带的 timestamp 只跟自己相关，如果一个时间戳较大的客户端 A 通过 NAT 与服务器建连，时间戳较小的客户端 B 通过 NAT 发送的包服务器认为是过期重复的数据，直接丢弃，导致 B 无法正常建连和发数据。</p>
<h2 id="21-爱搞事情的-RST-包-——-产生场景、Connection-reset-与-Broken-pipe"><a href="#21-爱搞事情的-RST-包-——-产生场景、Connection-reset-与-Broken-pipe" class="headerlink" title="21 爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe"></a>21 爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://nannaer.github.io/2023/04/27/TCP/" data-id="clhaexqgj0001dwv7f4l106qb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/04/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/27/TCP/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/20/%E5%86%85%E5%AD%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/04/15/JUC/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>